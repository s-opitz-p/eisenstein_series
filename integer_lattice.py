"""
Classes and functions for (even) lattices such that their vector valued
Eisenstein series (w.r.t the Weil representation) can be computed.
Symmetrized vector valued theta series can also be computed, the Siegel Weil Formula
provides test cases.

AUTHORS:

- Sebastian Opitz
"""

#*****************************************************************************
#       Copyright (C) 2018 Sebastian Opitz
#
#  Distributed under the terms of the GNU General Public License (GPL)
#
#    This code is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    General Public License for more details.
#
#  The full text of the GPL is available at:
#
#                  http://www.gnu.org/licenses/
#*****************************************************************************

from sage.misc.temporary_file import tmp_filename
from sage.quadratic_forms.quadratic_form import QuadraticForm
from sage.all import Zmod, RR, QQ, ZZ, kronecker_character, is_odd, is_even, prod, infinity, Zp, valuation, \
    hilbert_symbol, floor, Qp, sqrt, Integer, identity_matrix, diagonal_matrix, elementary_matrix, zero_matrix, \
    matrix, Matrix, sign, I, pi
from sage.modules.free_module_element import *
from sage.modules.free_module import *
from sage.matrix.matrix import is_Matrix
from sage.arith.all import GCD, LCM, valuation, is_prime, is_squarefree, kronecker_symbol, moebius, sigma, CRT
from sage.rings.big_oh import O
from sage.rings.infinity import Infinity
from sage.rings.integer_ring import IntegerRing, ZZ
from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
from sage.rings.rational_field import QQ
from sage.rings.qqbar import QQbar
from sage.rings.complex_field import ComplexField
from sage.rings.number_field.number_field import CyclotomicField
from sage.rings.finite_rings.integer_mod import Mod
from sage.functions.log import exp, log
from sage.quadratic_forms.special_values import quadratic_L_function__exact, gamma__exact, zeta__exact
from sage.functions.other import real, imaginary
from sage.groups.abelian_gps.abelian_group import AbelianGroup
from sage.groups.abelian_gps.abelian_group_morphism import AbelianGroupMorphism

from sage.misc.misc import uniq
from sage.structure.sage_object import load
from StringIO import StringIO
import itertools
import time
import sys
import copy



class Lattice(FreeModule_ambient_pid):
    r"""
    The ``Lattice`` class represents `\Z^n` endowed with a quadratic form in n variables with
    coefficients in the ring `\Z`.

    INPUT:

    The constructor may be called in any of the following ways.

    #. ``Lattice(R, n, entries)``, where

       - `R` -- ring over which the lattice is defined (currently only `\Z` is allowed)
       - `n` -- an integer >= 0
       - ``entries`` -- a list of `n(n+1)/2` coefficients of the quadratic form
         in `R` (given lexographically, or equivalently, by rows of the matrix)

    #. ``Lattice(R, n)``, where

       - `R` -- a ring (currently only `\Z` is allowed)
       - `n` -- a symmetric `n \times n` matrix with even diagonal (relative to
         `R`)

    #. ``Lattice(R)``, where

       - `R` -- a symmetric `n \times n` matrix with even diagonal (relative to
         its base ring (currently only `\Z` is allowed))

    #. ``Lattice(R)``, where

       - `R` -- a file (preferrably with extension .sage), a string, or a StringIO containig lattice data.
         The lattice data can be generated by the save method.

    
    OUTPUT:

    lattice

    EXAMPLES::

        sage: L = Lattice(ZZ, 3, [1,2,3,4,5,6])
        sage: L
        Lattice given by "Ambient free module of rank 3 over the principal ideal domain Integer Ring" endowed with the quadratic form "Quadratic form in 3 variables over Integer Ring with coefficients: 
        [ 1 2 3 ]
        [ * 4 5 ]
        [ * * 6 ]"

    ::

        sage: m = matrix(2,2,[1,2,3,4])
        sage: m + m.transpose()
        [2 5]
        [5 8]
        sage: Lattice(m + m.transpose())
        Lattice given by "Ambient free module of rank 2 over the principal ideal domain Integer Ring" endowed with the quadratic form "Quadratic form in 2 variables over Integer Ring with coefficients: 
        [ 1 5 ]
        [ * 4 ]"

    ::

        sage: m = matrix(2,2,[0,1,1,0])
        sage: L = Lattice(m)
        sage: s = L.save().getvalue()
        sage: print s[s.find('lattice_data'):]
        lattice_data=\
        {\
            'gram_matrix' : \
                matrix([\
                    [0, 1],\
                    [1, 0],\
                ]),\
        }
        sage: LL = Lattice(s)
        sage: LL
        Lattice given by "Ambient free module of rank 2 over the principal ideal domain Integer Ring" endowed with the quadratic form "Quadratic form in 2 variables over Integer Ring with coefficients: 
        [ 0 1 ]
        [ * 0 ]"
        sage: LL == L
        True

    """
        
    def __init__(self, R, n=None, entries=None):
        """
        EXAMPLES::

            sage: L = Lattice(ZZ, 4, range(10))
            sage: L == loads(dumps(L))
            True
        """
        self._lattice_data = {}
        self._p_isometries = {}
        self._isometries = None

        ## Deal with:  Lattice(file), Lattice(str) and Lattice(StringIO)
        if isinstance(R, (str, StringIO, file)):
            if isinstance(R, str):
                s = R
            elif isinstance(R, StringIO):
                s = R.getvalue()
            elif isinstance(R, file): # This now also handles files that did not have the extension '.sage'
                with open(R.name, 'r') as f:
                    s = f.read()
            with open(tmp_filename(ext = '.sage'), 'w') as f:
                f.write('from sage.all import O\n\n' + s)
            load(f.name)
            self._lattice_data = lattice_data
            self.Q = QuadraticForm(lattice_data.get('gram_matrix'))
            S = self.Q.matrix()
            _R = S.base_ring()
            n = S.parent().dims()[0]        
                
        ## Deal with:  Lattice(matrix)
        elif is_Matrix(R) and R.is_square():
            self.Q = QuadraticForm(R)
            S=R
            _R=S.base_ring()
            n=S.parent().dims()[0]
        ## Deal with:  Lattice(ring, dimension, entries)
        else:
            self.Q = QuadraticForm(R, n, entries)
            _R = R
        self._set_lattice_data('gram_matrix', self.Q.matrix())
        assert _R == ZZ, "the lattice has to be defined over the integers"
        FreeModule_ambient_pid.__init__(self,_R,n)
        self.Q_field = self.Q.base_change_to(self.base_field())   

    def copy(self):
        """
        Returns a copy of the lattice including the stored lattice data.

        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: LL = L.copy()
            sage: L._lattice_data == LL._lattice_data
            True
        
            sage: L.det()
            -1
            sage: L._lattice_data == LL._lattice_data
            False

        """
        return Lattice(self.save())

    def scaled(self, r):
        """
        Returns the lattice with its quadratic form scaled by the factor `right`.

        EXAMPLES::
            sage: L = Lattice(2 * matrix(2,2,[2,1,1,2]))
            sage: (L * (1/Integer(2))).gram_matrix()
            [2 1]
            [1 2]
            sage: (L * (1/Integer(4))).gram_matrix()
            Traceback (most recent call last):
            ...
            TypeError: Oops!  Can't scale this lattice by the given factor.

        """
        try:
            return Lattice((r * self.gram_matrix()).change_ring(ZZ))
        except:
            raise TypeError("Oops!  Can't scale this lattice by the given factor.")

    def latex_spreadsheet(self, template_filename = './latex_template'):
        """
        Returns a string containing the computed lattice data
        according to a template file in LaTeX format.
        """
        from string import Template
        with open(template_filename, 'r') as f:
            template = f.read()
        template = Template(template)
        from vector_valued_series import VectorValuedSeries
        from sage.misc.latex import latex
        gens = self.discriminant_form_gens()[0][self.discriminant_form_gens()[1].count(1):]
        try:
            lmfdb_label = self.lmfdb_label()
        except AttributeError:
            lmfdb_label = r"\text{none}"
        
        d = dict(genus_symbol = "{" + self.genus_symbol().replace(".", "}.{").replace("_", "}_{").replace("^", "}^{") + "}",
                 lmfdb_label = lmfdb_label,
                 gram_matrix = latex(self.gram_matrix()),
                 det = self.det(),
                 principal_divisors = latex(tuple(self.discriminant_form_gens()[1])),
                 generators = latex(tuple(matrix(self.dim(), 1, list(el)) for el in gens)),
                 isometry_orbits = self.isometry_orbits_to_latex()
                 )
        result = template.substitute(d)
        
        k = self.dim() / Integer(2)
        eis_prec = self._lattice_data.get('eisenstein_prec')
        if eis_prec:
            eis_prec = eis_prec[k]
            prec = self._lattice_data['eisenstein_prec'][k]
            eis_series = VectorValuedSeries(self._lattice_data['eisenstein_series'][k], prec)
            eis_series_orb = self.eisenstein_series_by_orbits(k, prec=prec)
            eis_series_orb = VectorValuedSeries(eis_series_orb, prec)
        else:
            eis_series = None
    
        if self._get_lattice_data('theta_prec') != None:
            th_series = VectorValuedSeries(self._get_lattice_data('theta_series'), self._get_lattice_data('theta_prec'))
        else:
            th_series = None
            
        if self._get_lattice_data('symmetrized_theta_prec') != None:
            sym_th_series = VectorValuedSeries(self._get_lattice_data('symmetrized_theta_series'), self._get_lattice_data('symmetrized_theta_prec'))
        else:
            sym_th_series = None

        if th_series != None:
            result += "Theta series (computed to precision {})".format(self._get_lattice_data('theta_prec'))
            if th_series == sym_th_series:
                result += ", "
            else:
                result += ":\\\\\n{}\\\\\n".format(latex(th_series))
        if sym_th_series != None:
            result += "Symmetrized Theta series (computed to precision {})".format(self._get_lattice_data('symmetrized_theta_prec'))
            if sym_th_series == eis_series:
                result += ", "
            else:
                result += ":\\\\\n{}\\\\\n".format(latex(sym_th_series))
        if eis_series != None:
            result += "Weight ${}$ Eisenstein series (computed to precision {}):\\\\\n{}\\\\\n".format(latex(k),self._get_lattice_data('eisenstein_prec')[k],eis_series_orb._latex_(orbit = True))
            
        return result

    def isometry_orbits_to_latex(self, max_rows = 45, max_cols = 9):
        """
        Returns a string containing a table of the isometry orbits of the discriminant form in LaTeX format.
        """
        from sage.misc.latex import latex
        orbits = self.isometry_orbits()
        n_rows = self.dim() * len(orbits)
        n_cols = max(len(orbit) for orbit in orbits)
        if n_rows > max_rows or n_cols > max_cols:
            return "{} orbits, the biggest of which has length {}.".format(len(orbits), n_cols)
        l = len(orbits[0][0])
        result = "\\begin{tabular}{l|l}\nnumber & orbit\\\\\\hline\n"

        for n in range(len(orbits)):
        
            orbit = orbits[n]
            result += "$" + str(n) + "$ & $"
            for el in orbit:
                m = matrix(l,1,list(el))
                result += latex(m) + ", "
            result = result[:-2] + "$\\\\\n"

        result += "\\end{tabular}"
        return result
        
    def genus_symbol(self):
        """
        Returns the genus symbol of this lattice as in psage.
        
        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L.genus_symbol()
            ''
        
            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: L.genus_symbol()
            '3^-1'

        """
        gen_sym = self._get_lattice_data('genus_symbol')
        if gen_sym != None:
            return gen_sym
        from finite_quadratic_module import FiniteQuadraticModule
        gen_sym = FiniteQuadraticModule(self.gram_matrix()).jordan_decomposition().genus_symbol()
        self._set_lattice_data('genus_symbol', gen_sym)
        return gen_sym

    def signature(self):
        """
        Returns the signature of the quadratic form of self.
        """
        s = self._get_lattice_data('signature')
        if s != None:
            return s
        s = self.Q.signature()
        self._set_lattice_data('signature', s)
        return s

    def b_plus(self):
        """
        Returns the number of positive eigenvalues of the Gram matrix of self.
        """
        return Integer((self.dim() + self.signature()) / 2)

    def b_minus(self):
        """
        Returns the number of positive eigenvalues of the Gram matrix of self.
        """
        return Integer((self.dim() - self.signature()) / 2)

    def _repr_(self):
        """
        Gives a text representation referring to the superclasses.
        """
        return 'Lattice given by "{0}" endowed with the quadratic form "{1}"'.format(FreeModule_ambient_pid._repr_(self), self.Q._repr_())

    def __call__(self, element):
        """
        Checks that element is defined over the base ring of this lattice and
        returns an element of type LatticeSpaceElementOverQQ for this lattice.
        
        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L((1,2))
            (1, 2)
        
            sage: type(L((1,2)))
            <class 'integer_lattice.LatticeSpaceElementOverQQ'>

        """
        if element in QQ:
            return self.scaled(element)
        el = FreeModule_ambient_pid.__call__(self, element)
        return LatticeSpaceElementOverQQ(self, tuple(el))
        
    def __eq__(self, other):
        """
        Determines if two latticess are equal.

        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L == L
            True

            sage: LL = L.copy()
            sage: L == LL
            True
        
            sage: LL = Lattice(matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: L == LL
            False
        
            sage: m = matrix(2 ,2 ,[2, 1, 1, 2])
            sage: m == LL
            False

        """
        if not isinstance(other,type(self)): return False
        return self.Q == other.Q

    
    def __add__(self, right):
        """
        Returns the direct sum of two lattices.

        EXAMPLES::
            sage: m0 = matrix(2,2,[0,1,1,0])
            sage: m1 = matrix(2,2,[2,1,1,2])
            sage: L0 = Lattice(m0)
            sage: L1 = Lattice(m1)
            sage: (L0 + L1).gram_matrix() == m0.block_sum(m1)
            True

        """
        if not isinstance(right, Lattice):
            raise TypeError("Oops!  Can't add these objects since they're not both lattices.")
        elif (self.Q.base_ring() != right.Q.base_ring()):
            raise TypeError("Oops!  Can't add these since the lattices don't have the same base rings.")
        else:
            return Lattice(self.gram_matrix().block_sum(right.gram_matrix()))

    def __mul__(self, right):
        """
        Return the lattice consisting of `right` number of copies of `self`.

        EXAMPLES::
            sage: L = Lattice(ZZ,2,[0,1,0])
            sage: (L*2).gram_matrix()
            [0 1 0 0]
            [1 0 0 0]
            [0 0 0 1]
            [0 0 1 0]
            sage: L * -1
            Traceback (most recent call last):
            ...
            ValueError: Cannot add this lattice to itself -1 times!

        """
        return self.__rmul__(right)
        
    def __rmul__(self, left):
        """
        Return the lattice consisting of `left` number of copies of `self`.

        EXAMPLES::
            sage: L = Lattice(ZZ,2,[0,1,0])
            sage: (2*L).gram_matrix()
            [0 1 0 0]
            [1 0 0 0]
            [0 0 0 1]
            [0 0 1 0]
            sage: -1 * L
            Traceback (most recent call last):
            ...
            ValueError: Cannot add this lattice to itself -1 times!

        """
        if left < 0 or not(left in ZZ):
            raise ValueError, "Cannot add this lattice to itself {0} times!".format(left)
        result_lattice = Lattice(ZZ,0,[])
        for j in range(left):
            result_lattice += self
        return result_lattice
        
                    
    def _set_lattice_data(self, key, value):
        """
        Assigns value to the _lattice_data dictionary under the key key.

        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L._lattice_data
            {'gram_matrix': [0 1]
             [1 0]}

            sage: L._set_lattice_data('bla', 'blub')
            sage: L._lattice_data
            {'bla': 'blub', 'gram_matrix': [0 1]
             [1 0]}

        """
        self._lattice_data[key] = value

    def _get_lattice_data(self, key, default = None):
        """
        Gets the value in the _lattice_data dictionary under the key key.
        If the dictionary does not have the key key, return the default value.

        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L._lattice_data
            {'gram_matrix': [0 1]
             [1 0]}
        
            sage: L._get_lattice_data('gram_matrix')
            [0 1]
            [1 0]
        
            sage: L._get_lattice_data('Gram_matrix')
        
            sage: L._get_lattice_data('Gram_matrix', 'default')
            'default'

        """
        return self._lattice_data.get(key, default)

    def save(self, file_name = None, overwrite=False, verbose=False):
        """
        Saves the computed lattice data (stored in self._lattice_data)
        to a file under the name 'file_name'. If no file name is given,
        then a StringIO object is returned.
        This "safe" method checks that the output can be used to
        reconstruct the lattice from this data and raises an IOError
        if this is not the case.

        INPUT:
            file_name -- string

            overwrite -- boolean

            verbose -- boolean

        EXAMPLES::

            sage: m = matrix(2,2,[2,1,1,2])
            sage: L = Lattice(m)
            sage: s = L.save().getvalue()
            sage: print s[s.find('lattice_data'):]
            lattice_data=\
            {\
            'gram_matrix' : \
                matrix([\
                    [2, 1],\
                    [1, 2],\
                ]),\
            }
        
            sage: LL = Lattice(s)
            sage: LL == L
            True

            sage: t = tmp_filename(ext = '.sage')
            sage: L.save(t)
            sage: with open(t) as f:
            ....:     LL = Lattice(f)
            ....:
            sage: L == LL
            True

            sage: L._lattice_data['L'] = L
            sage: L.save()
            Traceback (most recent call last):
            ...
            IOError: The lattice data which should be saved, cannot be loaded properly later. This should not have happened!

        """
        sIO = self._save()
        try:
            L = Lattice(sIO)
        except:
            raise IOError, 'The lattice data which should be saved, cannot be loaded properly later. This should not have happened!'
        assert L == self
        for k in self._lattice_data.keys():
            if not self._get_lattice_data(k) == L._get_lattice_data(k):
                raise IOError, 'The lattice data which should be saved, cannot be loaded properly later. This should not have happened!'
        if file_name:
            if overwrite:
                file_mode = "w+"
            else:
                file_mode = "a"
            with open(file_name, file_mode) as f:
                f.write(sIO.getvalue())
                f.flush()
                L = Lattice(f)
                assert L == self
                for k in self._lattice_data.keys():
                    if not self._get_lattice_data(k) == L._get_lattice_data(k):
                        raise IOError, 'The lattice data which was saved, cannot be loaded properly later. This should not have happened!'
        else:
            return sIO
        
    def _save(self, file_name = None, overwrite=False, verbose=False):
        """
        Saves the computed lattice data (stored in self._lattice_data)
        to a file under the name 'file_name'. If no file name is given,
        then a StringIO object is returned.
        This "unsafe" method does not check if the output can be used to
        reconstruct the lattice from this data.

        INPUT:
            file_name -- string

            overwrite -- boolean

            verbose -- boolean

        EXAMPLES::

            sage: m = matrix(2,2,[2,1,1,2])
            sage: L = Lattice(m)
            sage: s = L._save().getvalue()
            sage: print s[s.find('lattice_data'):]
            lattice_data=\
            {\
            'gram_matrix' : \
                matrix([\
                    [2, 1],\
                    [1, 2],\
                ]),\
            }
        
            sage: LL = Lattice(s)
            sage: LL == L
            True

            sage: t = tmp_filename(ext = '.sage')
            sage: L._save(t)
            sage: with open(t) as f:
            ....:     LL = Lattice(f)
            ....:
            sage: L == LL
            True

            sage: L._lattice_data['L'] = L
            sage: L._save()

        """
        m = self.Q.matrix()
        n = m.ncols()

        if self._isometries != None:
            self._isometries_to_isometric_images()

        intro = (
        "#This file contains lattice data computed by the Lattice class in integer_lattice.py\n"
        "#using code from sage and psage. The lattice can be reconstucted from this data within sage via\n"
        "#\n"
        "#sage: from integer_lattice import Lattice\n"
        "#sage: with open(name_of_this_file) as f:\n"
        "#....:     L = Lattice(f)\n"
        "#....:     \n"
        "#\n"
        "#Whenever there is a matrix representing images of generators,\n"
        "#the first row gives the coefficients of the image of the first generator, and so on.\n"
        "\n"
        "lattice_data=\\\n"
        )

        def write_stuff(f, stuff, indent = 4, level = 0):
            if isinstance(stuff, dict):
                f.write(level * " " + "{\\\n")
                for k in sorted(stuff.keys()):
                    write_stuff(f, k, indent = indent, level = level + indent)
                    f.write(" : \\\n")
                    write_stuff(f, stuff[k], indent = indent, level = level + 2 * indent)
                    f.write(",\\\n")
                f.write(level * " " + "}")
            elif isinstance(stuff, tuple):
                f.write(level * " " + "(\\\n")
                for k in stuff:
                    write_stuff(f, k, indent = indent, level = level + indent)
                    f.write(",\\\n")
                f.write(level * " " + ")")
            elif isinstance(stuff, list):
                f.write(level * " " + "[\\\n")
                for k in stuff:
                    write_stuff(f, k, indent = indent, level = level + indent)
                    f.write(",\\\n")
                f.write(level * " " + "]")
            elif isinstance(stuff, sage.matrix.matrix_generic_dense.Matrix_generic_dense) or \
                 isinstance(stuff, sage.matrix.matrix_rational_dense.Matrix_rational_dense) or \
                 isinstance(stuff, sage.matrix.matrix_integer_dense.Matrix_integer_dense):
                rows = stuff.rows()
                f.write(level * " " + "matrix([\\\n")
                for r in rows:
                    f.write((level + indent) * " " + str(r.list())+",\\\n")
                f.write(level * " " + "])")
            elif isinstance(stuff, str):
                f.write(level * " " + "'" + stuff + "'")
            else:
                f.write(level * " " + str(stuff))

        if file_name:
            if overwrite:
                file_mode = "w"
            else:
                file_mode = "a"
            with open(file_name, file_mode) as f:
                f.write(intro)
                write_stuff(f, self._lattice_data)
        else:
            f = StringIO()
            f.write(intro)
            write_stuff(f, self._lattice_data)
            return f
            
        if verbose:
            print "file '"+file_name+"' closed:", f.closed

    def lmfdb_label(self):
        """
        Returns the LMFDB label of this lattice.
        An internet connection is used for this.
        If this does not succeed, an IOError is returned.

        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: L.lmfdb_label()
            '2.3.3.1.1'

            sage: L._get_lattice_data('lmfdb_label')
            '2.3.3.1.1'

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L.lmfdb_label()
            Traceback (most recent call last)
            ...
            ValueError: Lattice not in LMFDB database, or no connection to database!

        """
        label = self._get_lattice_data('lmfdb_label')
        if label:
            return label
        import lmfdb_importer
        try:
            label = lmfdb_importer.lmfdb_label(self.Q.matrix())
        except:
            raise IOError, 'Lattice not in LMFDB database, or no connection to database!'
        self._set_lattice_data('lmfdb_label', label)
        return label

    def gram_matrix(self):
        """
        Returns the Gram matrix of this lattice.
        This is the Gram matrix of the corresponding bilinear form
        given by B(x,y) = Q(x+y) - Q(x) - Q(y) or B(x,x) = 2Q(x).

        EXAMPLES::

            sage: m = matrix(2,2,[2,1,1,2])
            sage: L = Lattice(m)
            sage: L.gram_matrix() == m
            True

        """
        return self.Q.matrix()

    def dim(self):
        """
        Returns the dimension of the Q vector space in which this lattice lives.
        
        EXAMPLES::

            sage: m = matrix(2,2,[2,1,1,2])
            sage: L = Lattice(m)
            sage: L.dim()
            2

        """
        return self.Q.dim()
        
    def det(self):
        """
        Returns the determinant of the Gram matrix of this lattice (self.gram_matrix())
        
        EXAMPLES::

            sage: m = matrix(2,2,[2,1,1,2])
            sage: L = Lattice(m)
            sage: L.det()
            3

            sage: L._get_lattice_data('det')
            3

        """
        d = self._get_lattice_data('det')
        if d:
            return d
        d = self.Q.det()
        self._set_lattice_data('det', d)
        return d
        
    def is_positive_definite(self):
        """
        Checks whether this lattice is positive definite.
        
        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L.is_positive_definite()
            False
        
            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: L.is_positive_definite()
            True

        """
        return self.Q.is_positive_definite()
            
    def det_squarefree_part(self):
        """
        Returns squarefree part of the determinant of the Gram matrix of this lattice (self.gram_matrix())
        
        EXAMPLES::

            sage: L = Lattice(4 * matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: L.det()
            48
            sage: L.det_squarefree_part()
            3

            sage: L._get_lattice_data('det_squarefree_part')
            3
        
        """
        d_sf = self._get_lattice_data('det_squarefree_part')
        if d_sf:
            return d_sf
        d_sf = self.det().squarefree_part()
        self._set_lattice_data('det_squarefree_part', d_sf)
        return d_sf
        
    def dual_gram_matrix(self):
        """
        Returns the Gram matrix of the dual lattice. (This is simply the inverse of self.gram_matrix())
        
        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: L.dual_gram_matrix()
            [ 2/3 -1/3]
            [-1/3  2/3]

            sage: L._get_lattice_data('dual_gram_matrix')
            [ 2/3 -1/3]
            [-1/3  2/3]
        
        """
        S = self._get_lattice_data('dual_gram_matrix')
        if S == None:
            S=self.gram_matrix()**(-1)
            self._set_lattice_data('dual_gram_matrix', S)
        return S

    def level(self):
        """
        Returns the level of this lattice.
        
        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: L.level()
            3

            sage: L = Lattice(matrix(1 ,1 ,[2]))
            sage: L.level()
            4
        
            sage: L = Lattice(2 * matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L.level()
            2
        
        """
        l = self._get_lattice_data('level')
        if l:
            return l
        sf = self._get_lattice_data('smith_normal_form')
        if sf:
            N = self.smith_form()[0][-1,-1]
        else:
            N = self.gram_matrix().elementary_divisors()[-1]
        diag = self.dual_gram_matrix().diagonal()
        if all([Integer(N*x) % 2 == 0 for x in diag]):
            l = N
        else:
            l = 2*N
        self._set_lattice_data('level', l)
        return l

    def smith_form(self):
        """
        Returns the Smith form of the Gram matrix.
        
        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L.smith_form()
            (
            [1 0]  [0 1]  [1 0]
            [0 1], [1 0], [0 1]
            )
        
            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: L.smith_form()
            (
            [1 0]  [ 0  1]  [ 1  2]
            [0 3], [ 1 -2], [ 0 -1]
            )
        
        """
        s_form = self._get_lattice_data('smith_normal_form')
        if s_form:
            return s_form
        s_form = self.gram_matrix().smith_form()
        self._set_lattice_data('smith_normal_form', s_form)
        return s_form

    def _vector_pres_to_fin_ab_grp_pres(self, alpha):
        """
        Given a representative of an element of the discriminant form for this lattice (i.e. dual lattice module lattice),
        return a representation of this element in the finite abelian group Z/d_1Z x ... x Z/d_nZ, where the d_i are
        the principal divisors of this lattice.
        Compare _fin_ab_grp_pres_to_vector_pres.
        
        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: el = L._vector_pres_to_fin_ab_grp_pres((1,1))
            sage: el.order()
            1
            sage: L._fin_ab_grp_pres_to_vector_pres(el)
            (0, 0)

            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: el = L._vector_pres_to_fin_ab_grp_pres((1,1))
            sage: el.order()
            1
            sage: L._fin_ab_grp_pres_to_vector_pres(el)
            (0, 0)

            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: el = L._vector_pres_to_fin_ab_grp_pres((1/3,1/3))
            sage: el.order()
            3
            sage: L._fin_ab_grp_pres_to_vector_pres(el)
            (1/3, 1/3)
        
        """
        D, U, V = self.smith_form()
        n = D.ncols()
        #d = [d for d in D.diagonal() if d!= 1] Note: This causes problems when symmetrizing the theta series.
        d = D.diagonal()
        v = matrix(n, 1, list(alpha))
        v = (D * V**-1 * v).list()
        A = AbelianGroup(d)
        #return A(v[-len(d):]) Note: Currently not necessary.
        return A(v)

    def _fin_ab_grp_pres_to_vector_pres(self, alpha):
        """
        Given a representation of this element in the finite abelian group Z/d_1Z x ... x Z/d_nZ,
        where the d_i are the principal divisors of this lattice,
        return a representative of an element of the discriminant form for this lattice (i.e. dual lattice module lattice).
        Compare _vector_pres_to_fin_ab_grp_pres.
        
        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: el = L._vector_pres_to_fin_ab_grp_pres((1,1))
            sage: el.order()
            1
            sage: L._fin_ab_grp_pres_to_vector_pres(el)
            (0, 0)

            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: el = L._vector_pres_to_fin_ab_grp_pres((1,1))
            sage: el.order()
            1
            sage: L._fin_ab_grp_pres_to_vector_pres(el)
            (0, 0)

            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: el = L._vector_pres_to_fin_ab_grp_pres((1/3,1/3))
            sage: el.order()
            3
            sage: L._fin_ab_grp_pres_to_vector_pres(el)
            (1/3, 1/3)
        
        """
        D, U, V = self.smith_form()
        n = D.ncols()
        if alpha == 1:
            # This is necessary, as group homomorphisms might return Integer(1)
            # instead of the neutral elment of the codomain.
            v = []
        else:
            v = alpha.list()
        v = [0 for k in range(n-len(v))] + v
        v = matrix(n,1,v)
        v = (V * D**-1 * v).list()
        v = map(lambda x: x - floor(x), v)
        return LatticeSpaceElementOverQQ(self, v)
        
    def discriminant_form_gens(self):
        """
        Returns generators for the discriminant form and their orders.
        The orders are also the principal divisors of this lattice.

        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L.discriminant_form_gens()
            ([(0, 0), (0, 0)], [1, 1])

            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: L.discriminant_form_gens()
            ([(0, 0), (2/3, 2/3)], [1, 3])

            sage: L = Lattice(matrix(2 ,2 ,[12, 0, 0, 18]))
            sage: L.discriminant_form_gens()
            ([(5/6, 1/6), (11/12, 1/18)], [6, 36])

        """
        d_f_gens = self._get_lattice_data('discriminant_form_gens')
        if d_f_gens:
            gs = d_f_gens['generators']
            d = d_f_gens['orders']
        else:
            D, U, V = self.smith_form()
            #d = [d for d in D.diagonal() if d!= 1] Note: This makes the CRT harder to implement
            d = D.diagonal()
            v = V.columns()[-len(d):]
            gs = [v[k] / d[k] for k in range(len(d))]
            gs = map(lambda x: [k - floor(k) for k in x], gs)
            d_f_gens = {'generators' : gs, 'orders' : d}
            self._set_lattice_data('discriminant_form_gens', d_f_gens)
        gs = map(lambda x: LatticeSpaceElementOverQQ(self, x), gs)
        return gs, d

    #def discriminant_form_gram_matrix(self):
    #    """
    #    Returns a Gram matrix of the discriminant form.
    #    """
    #    gs, d = self.discriminant_form_gens()
    #    n = len(d)
    #    m = zero_matrix(QQ, n, n)
    #    for j1 in range(n):
    #        for j2 in range(n):
    #            m[j1, j2] = gs[j1].inner_product(gs[j2])
    #    return m

    def discriminant_form_isometries(self, verbose = False, algorithm = 'CRT', use_orbit_invariants = True):
        """
        Computes isometries for this lattice. The isometries are given as isomporphisms of
        the finite abelian group Z/d_1Z x ... x Z/d_nZ, where the d_i are the principal divisors of this lattice.
        If these isometries have been previously computed, the result is recalled.
        
        INPUT:

        'algortithm' -- string equal to one of 'CRT' (default), 'naive', 'both'

        AVAILABLE ALGORITHMS:

        'CRT' - Look for isometries on the p-groups of the discriminant form by enumerating possible images for the generators
        and checking whether the map generated by these images yields an isometry.
        The isometries on the p-groups are combined via the Chinese Remainder Theorem.

        'naive' - No decomposition into p-groups. This is much slower but can be used to test 'CRT'.

        'both' - Running both of the above algorithms and checking that they agree. This is much slower but can be used to test 'CRT'.

        OUTPUT:

        A list of isometries for the lattice gives as isomorphisms of a finite abelian group.
        
        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: isoms = L.discriminant_form_isometries()
            sage: len(isoms)
            1
            sage: isom = isoms[0]
            sage: d = isom.domain()
            sage: g0 = d.gens()[0]
            sage: g1 = d.gens()[1]
            sage: g0 == d(isom(g0))
            True
            sage: g1 == d(isom(g1))
            True

            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: isoms = L.discriminant_form_isometries()
            sage: len(isoms)
            2
            sage: isom = isoms[0]
            sage: d = isom.domain()
            sage: g0 = d.gens()[0]
            sage: g1 = d.gens()[1]
            sage: g0 == d(isom(g0))
            True
            sage: g1 == isom(g1) or g1** 2 == d(isom(g1))
            True
            sage: isom = isoms[1]
            sage: g0 == d(isom(g0))
            True
            sage: g1 == isom(g1) or g1** 2 == d(isom(g1))
            True
        
        """
        if algorithm not in ('CRT', 'naive', 'both'):
            raise ValueError, "algorithm should be one of 'CRT', 'naive' or 'both'. Given: {}".format(algorithm)
        if self._isometries != None:
            if verbose:
                print "Isometries have been computed before."
            return self._isometries
        if self._lattice_data.get('isometric_images_of_generators') != None:
            if verbose:
                print "Isometric images have been computed before."
            return self._isometric_images_to_isometries()
        if algorithm in ('CRT', 'both'):
            if verbose:
                print "START Computing isometries via CRT:", time.asctime()
            crt_isos = self._discriminant_form_isometries_crt(verbose = verbose, use_orbit_invariants = use_orbit_invariants)
        if algorithm in ('naive', 'both'):
            if verbose:
                print "START Computing naive isometries:", time.asctime()
            naive_isos = self._discriminant_form_isometries_naive(verbose = verbose)
        if verbose:
            print "DONE:", time.asctime()
        if verbose and algorithm == 'both':
            b = len(naive_isos) == len(crt_isos)
            b &= naive_isos[0].domain() == crt_isos[0].domain()
            if b:
                gensA = naive_isos[0].domain().gens()
                naive_images = tuple([tuple([tuple(iso(g).list()) for g in gensA]) for iso in naive_isos])
                crt_images = tuple([tuple([tuple(iso(g).list()) for g in gensA]) for iso in crt_isos])
                naive_uniq = sorted(uniq(naive_images))
                crt_uniq = sorted(uniq(crt_images))
                b &= naive_uniq == crt_uniq and len(crt_uniq) == len(crt_images)
            if b:
                print b, "-> isometries computed via CRT and in a naive way coincide!"
            else:
                print b, "-> isometries computed via CRT and in a naive way do NOT coincide!"
                raise RuntimeError, "Isometries computed via CRT and in a naive way do NOT coincide!"

        if algorithm == 'CRT':
            self._isometries = crt_isos
        else:
            self._isometries = naive_isos
        return self._isometries

    def _isometric_images_to_isometries(self, p=-1):
        """
        Gives isometries for the discriminant form of this lattice. The isometries are given as isomporphisms of
        the finite abelian group Z/d_1Z x ... x Z/d_nZ, where the d_i are the principal divisors of this lattice.
        If these isometries have been previously computed, the result is recalled.
        If a prime p is given, return the isometries of the corresponding p-group.

        This funtion will call self.discriminant_form_isometries(), if self._isometries and
        self._get_lattice_data('isometric_images_of_generators') are both None.

        The purpose of this function is to convert stored representations of images of genreators (as rows of integer matrizes)
        to isometries of the discriminant form of this lattice as given by self.discriminant_form_isometries().
        
        INPUT:

        'p' -- -1 (default, for isometries of the complete group), or a prime (for isometries of the corresponding p-group) 

        OUTPUT:

        A list of isometries for the discriminant form of this lattice given as isomorphisms of a finite abelian group.
        
        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: len(L._isometric_images_to_isometries())
            1

            ## False values are used, if they are provided:
            ## --------------------------------------------
            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L._set_lattice_data('isometric_images_of_generators', [zero_matrix(2,2), zero_matrix(2,2)])
            sage: len(L._isometric_images_to_isometries())
            2

            ## Values from self._isometries (rsp. self._p_isometries) are used, if they are not None (rsp. {}),
            ## Copies do not have these values anymore:
            ## ----------------------------------------------------------------------------------------
            sage: L = Lattice(matrix(2 ,2 ,[12, 0, 0, 18]))
            sage: len(L._isometric_images_to_isometries(2))
            2
            sage: len(L._isometric_images_to_isometries(3))
            12
            sage: L._get_lattice_data('local_isometric_images_of_generators')
            sage: d = {2 : [identity_matrix(2)], 3 : [identity_matrix(2)]}
            sage: L._set_lattice_data('local_isometric_images_of_generators', d)
            sage: L._get_lattice_data('local_isometric_images_of_generators') == d
            True
            sage: len(L._isometric_images_to_isometries(2))
            2
            sage: len(L._isometric_images_to_isometries(3))
            12
            sage: len(L.copy()._isometric_images_to_isometries(3))
            1
            sage: len(L.copy()._isometric_images_to_isometries(2))
            1
            sage: len(L.copy().discriminant_form_isometries())
            1
            sage: L._p_isometries = {}
            sage: len(L._isometric_images_to_isometries(2))
            1
            sage: len(L._isometric_images_to_isometries(3))
            1
            sage: len(L.discriminant_form_isometries())
            1
            sage: L = L.copy()
            sage: len(L.discriminant_form_isometries())
            1

            ## To safely recompute isometries, do:
            ## -----------------------------------
            sage: L = L.copy()
            sage: L._isometries = None
            sage: L._p_isometries = {}
            sage: L._set_lattice_data('local_isometric_images_of_generators', {})
            sage: L._set_lattice_data('isometric_images_of_generators', None)
            sage: len(L._isometric_images_to_isometries(2))
            2
            sage: len(L._isometric_images_to_isometries(3))
            12

        """
        if p == -1:
            if self._isometries != None:
                return self._isometries
            if self._lattice_data.get('isometric_images_of_generators') == None:
                return self.discriminant_form_isometries()
            ims = self._get_lattice_data('isometric_images_of_generators')
            gs, d = self.discriminant_form_gens()
            n = len(d)
            A = AbelianGroup(d)
            gensA = A.gens()
            isos = []
            for im in ims:
                try:
                    iso = AbelianGroupMorphism(A, A, gensA, [A(r) for r in im.rows()]) # For some reason, this does not always work.
                except RuntimeError:
                    if A.order() == 1:
                        from sage.all import Hom
                        iso = Hom(A, A).identity()
                    else:
                        raise
                isos.append(iso)
            self._isometries = isos
            return self._isometries
        elif Integer(p).is_prime():
            if self._p_isometries != None and self._p_isometries.has_key(p):
                return self._p_isometries[p]
            if self._get_lattice_data('local_isometric_images_of_generators') == None or not self._get_lattice_data('local_isometric_images_of_generators').has_key(p):
                return self.discriminant_form_p_isometries(p)
            ims_p = self._get_lattice_data('local_isometric_images_of_generators')[p]
            gs, d = self.discriminant_form_gens()
            n = len(d)
            d_p = [p**(d[j].valuation(p)) for j in range(n)]
            A_p = AbelianGroup(d_p)
            gensA_p = A_p.gens()
            isos_p = []
            for im_p in ims_p:
                try:
                    iso_p = AbelianGroupMorphism(A_p, A_p, gensA_p, [A_p(r) for r in im_p.rows()]) # For some reason, this does not always work.
                except RuntimeError:
                    if A_p.order() == 1:
                        from sage.all import Hom
                        iso_p = Hom(A_p, A_p).identity()
                    else:
                        raise
                isos_p.append(iso_p)
            self._p_isometries[p] = isos_p
            return self._p_isometries[p]
        else:
            raise ValueError, "Expected a prime for local isometries, or -1 for global isometries. Given: {0}".format(p)

    def _isometries_to_isometric_images(self, p=-1):
        """
        Gives a list of matrizes where each matrix represents an isometry of the discriminant form of this lattice.    
        The discriminant form is isomorphic to the finite abelian group Z/d_1Z x ... x Z/d_nZ,
        where the d_i are the principal divisors of this lattice.
        Using the generators (1,0,...,0), (0,1,0,...,0),...,(0,...,0,1) for this group,
        the i-th row of a matrix represents the image of the i-th generator of the above group.
        
        If these isometries have been previously computed, the result is recalled.
        If a prime p is given, return the isometries of the corresponding p-group.

        This funtion will call self.discriminant_form_isometries(), if self._isometries and
        self._get_lattice_data('isometric_images_of_generators') are both None.

        The purpose of this function is to convert isometries of this lattice as given by self.discriminant_form_isometries()
        to representations of images of genreators (as rows of integer matrizes) such that these can be stored (by self.save(file_name)).
        
        INPUT:

        'p' -- -1 (default, for isometries of the complete group), or a prime (for isometries of the corresponding p-group) 

        OUTPUT:

        A list of isometries for the discriminant form of this lattice given as integer matrices.
        
        EXAMPLES::
        
            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))sage: len(L._isometries_to_isometric_images())
            1

            ## False values are used, if they are provided:
            ## --------------------------------------------
            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L._set_lattice_data('isometric_images_of_generators', [zero_matrix(2,2), zero_matrix(2,2)])
            sage: len(L._isometries_to_isometric_images())
            2

            ## Values from self._isometries (rsp. self._p_isometries) are used, if they are not None (rsp. {}),
            ## Copies do not have these values anymore:
            ## ----------------------------------------------------------------------------------------
            sage: L = Lattice(matrix(2 ,2 ,[12, 0, 0, 18]))
            sage: len(L._isometries_to_isometric_images())
            24
            sage: L._set_lattice_data('isometric_images_of_generators', [identity_matrix(2)])
            sage: len(L.discriminant_form_isometries())
            1
            sage: LL = L.copy()
            sage: LL._set_lattice_data('isometric_images_of_generators', None)
            sage: LL._isometries = L.discriminant_form_isometries()
            sage: LL._isometries_to_isometric_images() == [identity_matrix(2)]
            True

            ## To safely recompute isometries, do:
            ## -----------------------------------
            sage: LL = LL.copy()
            sage: LL._isometries = None
            sage: LL._p_isometries = {}
            sage: LL._set_lattice_data('local_isometric_images_of_generators', {})
            sage: LL._set_lattice_data('isometric_images_of_generators', None)
            sage: len(LL._isometries_to_isometric_images())
            24

        """
        if p == -1:
            if self._get_lattice_data('isometric_images_of_generators') != None:
                return self._get_lattice_data('isometric_images_of_generators')
            isos = self.discriminant_form_isometries()
            A = isos[0].domain()
            gensA = A.gens()
            images = [matrix([A(iso(g)).list() for g in gensA]) for iso in isos]
            self._set_lattice_data('isometric_images_of_generators', images)
            return images
        elif Integer(p).is_prime():
            if self._get_lattice_data('local_isometric_images_of_generators') != None and self._get_lattice_data('local_isometric_images_of_generators').has_key(p):
                return self._get_lattice_data('local_isometric_images_of_generators')[p]
            isos_p = self.discriminant_form_p_isometries(p)
            A_p = isos_p[0].domain()
            gensA_p = A_p.gens()
            images_p = [matrix([A_p(iso_p(g)).list() for g in gensA_p]) for iso_p in isos_p]
            if self._get_lattice_data('local_isometric_images_of_generators') == None:
                self._set_lattice_data('local_isometric_images_of_generators', {})
            self._lattice_data['local_isometric_images_of_generators'][p] = images_p
            return images_p
        else:
            raise ValueError, "Expected a prime for local isometries, or -1 for global isometries. Given: {0}".format(p)        
        
    def _discriminant_form_isometries_naive(self, verbose = False):
        """
        Computes isometries for this lattice. The isometries are given as isomporphisms of
        the finite abelian group Z/d_1Z x ... x Z/d_nZ, where the d_i are the principal divisors of this lattice.

        This is done by enumerating possible images for the generators and checking whether the map generated by
        these images yields an isometry.
        
        OUTPUT:

        A list of isometries for the lattice gives as isomorphisms of a finite abelian group.
        
        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: isoms = L._discriminant_form_isometries_naive()
            sage: len(isoms)
            1
            sage: isom = isoms[0]
            sage: d = isom.domain()
            sage: g0 = d.gens()[0]
            sage: g1 = d.gens()[1]
            sage: g0 == d(isom(g0))
            True
            sage: g1 == d(isom(g1))
            True

            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: isoms = L._discriminant_form_isometries_naive()
            sage: len(isoms)
            2
            sage: isom = isoms[0]
            sage: d = isom.domain()
            sage: g0 = d.gens()[0]
            sage: g1 = d.gens()[1]
            sage: g0 == d(isom(g0))
            True
            sage: g1 == isom(g1) or g1** 2 == d(isom(g1))
            True
            sage: isom = isoms[1]
            sage: g0 == d(isom(g0))
            True
            sage: g1 == isom(g1) or g1** 2 == d(isom(g1))
            True
        
        """
        if verbose:
            print "Computing isometries."
        gs, d = self.discriminant_form_gens()
        n = len(d)
        v = [vector(g.list()) for g in gs]
        qs = [g.Q()-floor(g.Q()) for g in gs]
        A = AbelianGroup(d)
        gensA = A.gens()
        def lat_el(a):
            b = A(a).list()
            l = (sum(b[k]*v[k] for k in range(n))).list()
            return LatticeSpaceElementOverQQ(self, l)
        def Q(a):
            return lat_el(a).Q()
        def B(a,b):
            return Q(A(a)*A(b)) - Q(a) - Q(b)
        images = dict()
        for k in range(n):
            o = d[k]
            q = qs[k]
            if not (o,q) in images.keys():
                images[(o,q)] = [a for a in A if a.order() == o and (Q(a)-q).is_integer()]
        isometries = []
        for im_gens in itertools.product(*[images[(f.order(),Q(f)-floor(Q(f)))] for f in gensA]):
            try:
                h = AbelianGroupMorphism(A, A, gensA, im_gens) # For some reason, this does not always work.
            except RuntimeError:
                if A.order() == 1:
                    from sage.all import Hom
                    h = Hom(A, A).identity()
                else:
                    raise
            b = True
            for j1 in range(n):
                g1 = gensA[j1]
                for j2 in range(j1):
                    g2 = gensA[j2]
                    b = (B(g1,g2)- B(h(g1),h(g2))).is_integer()
                    if not b:
                        break
                if not b:
                    break
            if b:
                isometries.append(h)
            if verbose:
                print b, im_gens
                print map(lat_el, list(im_gens))
        if verbose:
            "Done computing isometries."
        return isometries

    def _discriminant_form_isometries_crt(self, verbose = False, use_orbit_invariants = True):
        """
        Computes isometries for this lattice. The isometries are given as isomporphisms of
        the finite abelian group Z/d_1Z x ... x Z/d_nZ, where the d_i are the principal divisors of this lattice.
        
        This is done by looking for isometries on the p-groups of the discriminant form by enumerating possible
        images for the generators and checking whether the map generated by these images yields an isometry.
        The isometries on the p-groups are combined via the Chinese Remainder Theorem.

        OUTPUT:

        A list of isometries for the lattice gives as isomorphisms of a finite abelian group.
        
        EXAMPLES::

            sage: isoms = L._discriminant_form_isometries_crt()
            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: isoms = L._discriminant_form_isometries_crt()
            sage: len(isoms)
            1
            sage: isom = isoms[0]
            sage: d = isom.domain()
            sage: g0 = d.gens()[0]
            sage: g1 = d.gens()[1]
            sage: g0 == d(isom(g0))
            True
            sage: g1 == d(isom(g1))
            True

            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: isoms = L._discriminant_form_isometries_crt()
            sage: len(isoms)
            2
            sage: isom = isoms[0]
            sage: d = isom.domain()
            sage: g0 = d.gens()[0]
            sage: g1 = d.gens()[1]
            sage: g0 == d(isom(g0))
            True
            sage: g1 == isom(g1) or g1** 2 == d(isom(g1))
            True
            sage: isom = isoms[1]
            sage: g0 == d(isom(g0))
            True
            sage: g1 == isom(g1) or g1** 2 == d(isom(g1))
            True
        
        """
        S = self.det().prime_divisors()
        if verbose:
            print "S:", S
        gs, d = self.discriminant_form_gens()
        n = len(d)
        A = AbelianGroup(d)
        gensA = A.gens()
        
        #We frequntly need the same Chinese remainder thm., so we compute
        d_p = {}
        d_divided_by_d_p = {}
        crt_list = {}
        for p in S:
             d_p[p] = [p**(d[j].valuation(p)) for j in range(n)]
             d_divided_by_d_p[p] = [Integer(d[j]/d_p[p][j]) for j in range(n)]
             crt_list[p] = [Integer(Mod(d_divided_by_d_p[p][j], d_p[p][j])**-1) for j in range(n)]
             
        isometries = []
        if verbose:
            counter = 0
        for p_isos in itertools.product(*[self.discriminant_form_p_isometries(S[j], verbose=verbose, use_orbit_invariants=use_orbit_invariants) for j in range(len(S))]):
            im_gens = []
            if verbose:
                counter += 1
                print 20 * "*" + "counter:", counter
            for j in range(n):
                p_image = {}
                for p_index in range(len(S)):
                    p_iso = p_isos[p_index]
                    dom = p_iso.domain()
                    p_image[S[p_index]] = (dom(p_iso(dom.gens()[j]))).list()
                    if verbose:
                        print dom
                        print dom.gens()[j]
                        print p_iso(dom.gens()[j])
                        print dom(p_iso(dom.gens()[j]))
                        print dom(p_iso(dom.gens()[j])).list()
                        print S[p_index], p_image
                if verbose:
                    print "j:", j
                    print "d:", d
                    print "d_p:", d_p
                    print "d_divided_by_d_p:", d_divided_by_d_p
                    print "crt_list:", crt_list
                crt_image = [sum([p_image[p][k]*crt_list[p][k]*d_divided_by_d_p[p][k] for p in S]) for k in range(n)]
                if verbose:
                    print "crt_image:", crt_image
                im_gens.append(A(crt_image))
            try:
                iso = AbelianGroupMorphism(A, A, gensA, im_gens) # For some reason, this does not always work.
            except RuntimeError:
                if A.order() == 1:
                    from sage.all import Hom
                    iso = Hom(A, A).identity()
                else:
                    raise
            isometries.append(iso)
            
        return isometries    

    def discriminant_form_p_isometries_old(self, p, verbose = False):
        """
        Gives isometries for the maximal p-subgroup of the discriminant form of this lattice. The isometries are given
        as isomporphisms of the finite abelian group Z/d_1Z x ... x Z/d_nZ, where the d_i are the maximal
        p-powers dividing the  principal divisors of this lattice.
        If these isometries have been previously computed, the result is recalled.
        
        INPUT:

        'p' -- a prime

        OUTPUT:

        A list of isometries for the maximal p-subgroup of the discriminant form of this lattice
        given as isomorphisms of a finite abelian group.
        
        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: len(L.discriminant_form_p_isometries(2))
            1

            ## False values are used, if they are provided:
            ## --------------------------------------------
            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L._p_isometries = {2 : [L._p_isometries[2][0] for j in range(2)]}
            sage: len(L.discriminant_form_p_isometries(2))
            2
            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L._set_lattice_data('local_isometric_images_of_generators', {2 : [zero_matrix(2,2), zero_matrix(2,2)]})
            sage: len(L._isometric_images_to_isometries())
            2

            ## Values from self._p_isometries are used, if possible.
            ## Copies do not have these values anymore:
            ## ----------------------------------------------------------------------------------------
            sage: L = Lattice(matrix(2 ,2 ,[12, 0, 0, 18]))
            sage: len(L.discriminant_form_p_isometries(2))
            2
            sage: len(L.discriminant_form_p_isometries(3))
            12
            sage: L._get_lattice_data('local_isometric_images_of_generators')
            sage: d = {2 : [identity_matrix(2)], 3 : [identity_matrix(2)]}sage: L._set_lattice_data('local_isometric_images_of_generators', d)
            sage: L._get_lattice_data('local_isometric_images_of_generators') == d
            True
            sage: len(L.discriminant_form_p_isometries(2))
            2
            sage: len(L.discriminant_form_p_isometries(3))
            12
            sage: len(L.copy().discriminant_form_p_isometries(2))
            1
            sage: len(L.copy().discriminant_form_p_isometries(3))
            1
            sage: L._p_isometries = {}
            sage: len(L.discriminant_form_p_isometries(2))
            1
            sage: len(L.discriminant_form_p_isometries(3))
            1 

            ## To safely recompute isometries, do:
            ## -----------------------------------
            sage: L = L.copy()
            sage: L._isometries = None
            sage: L._p_isometries = {}
            sage: L._set_lattice_data('local_isometric_images_of_generators', {})
            sage: L._set_lattice_data('isometric_images_of_generators', None)
            sage: len(L.discriminant_form_p_isometries(2))
            2
            sage: len(L.discriminant_form_p_isometries(3))
            12

        """
        if self._p_isometries == None:
            self._p_isometries = {}
        if self._p_isometries.has_key(p):
            if verbose:
                print str(p) + "-Isometries have been computed before."
            return self._p_isometries[p]
        if self._lattice_data.get('local_isometric_images_of_generators') != None and self._lattice_data['local_isometric_images_of_generators'].has_key(p):
            if verbose:
                print str(p) + "-Isometric images have been computed before."
            return self._isometric_images_to_isometries(p)
        if verbose:
            print "Computing " + str(p) + "-isometries."
        gs, d = self.discriminant_form_gens()
        n = len(d)
        d_p = [p**(d[j].valuation(p)) for j in range(n)]
        d_divided_by_d_p = [Integer(d[j]/d_p[j]) for j in range(n)]
        gs_p = [LatticeSpaceElementOverQQ(self,(Integer(Mod(d_divided_by_d_p[j], d_p[j])**-1)*d_divided_by_d_p[j]*vector(gs[j].list())).list()) for j in range(n)]
        v_p = [vector(g.list()) for g in gs_p]
        qs_p = [g.Q()-floor(g.Q()) for g in gs_p]
        A_p = AbelianGroup(d_p)
        gensA_p = A_p.gens()
        
        def lat_el(a_p):
            b_p = a_p.list()
            if verbose and False:
                print a_p, b_p, v_p, n
            l = (sum(b_p[k]*v_p[k] for k in range(n))).list()
            return LatticeSpaceElementOverQQ(self, l)
        def Q(a):
            return lat_el(a).Q()
        def B(a,b):
            a = A_p(a)
            b = A_p(b)
            return Q(a*b) - Q(a) - Q(b)
        images = dict()
        for k in range(n):
            o = d_p[k]
            q = qs_p[k]
            if not (o,q) in images.keys():
                images[(o,q)] = [a for a in A_p if a.order() == o and (Q(a)-q).is_integer()]
        isometries = []

        ## New loop
        ##---------------------------------------------------------------------------------------
        #j = 0
        #im_gens = [0 for f in gensA_p]
        #possibilities = [images[(f.order(),Q(f)-floor(Q(f)))] for f in gensA_p]
        #while j >= 0:
        #
        #    if verbose:
        #        print j*" ", j, im_gens
        #        print j*" ", possibilities[j]
        #        print j*" ", [len(p) for p in possibilities]
        #    
        #    if possibilities[j] == []:
        #        im_gens[j] = 0
        #        j = j-1
        #        continue
        #    else:
        #        im_gens[j] = possibilities[j].pop()
        #    if A_p.subgroup(im_gens[:j+1]).order() != A_p.subgroup(gensA_p[:j+1]).order():
        #        if verbose:
        #            print j*" ", "Not possible for an isomorphism:"
        #            print j*" ", im_gens[:j+1]
        #        continue
        #    else:
        #        if j < n-1:
        #            j = j+1
        #            possibilities[j]=images[(gensA_p[j].order(),Q(gensA_p[j])-floor(Q(gensA_p[j])))][:]
        #        else:
        #            # Found at least an isomorphism:
        #            try:
        #                h = AbelianGroupMorphism(A_p, A_p, gensA_p, im_gens) # For some reason, this does not always work.
        #            except RuntimeError:
        #                if A_p.order() == 1:
        #                    from sage.all import Hom
        #                    h = Hom(A_p, A_p).identity()
        #                else:
        #                    raise
        #            # Found an isometry?
        #            b = True
        #            for j1 in range(n):
        #                g1 = gensA_p[j1]
        #                for j2 in range(j1):
        #                    g2 = gensA_p[j2]
        #                    b = (B(g1,g2)- B(h(g1),h(g2))).is_integer()
        #                    if not b:
        #                        break
        #                if not b:
        #                    break
        #            if b:
        #                # Found an isometry!
        #                isometries.append(h)
        #                if verbose:
        #                    print [(h.domain()(h(h.domain().gens()[j]))).list() for j in range(n)]
        #            if verbose:
        #                print b, im_gens
        #                print map(lat_el, list(im_gens))
        ##----------------------------------------------------------------------------------------
                
        ## Old loop
        ##----------------------------------------------------------------------------------------
        for im_gens in itertools.product(*[images[(f.order(),Q(f)-floor(Q(f)))] for f in gensA_p]):
            try:
                h = AbelianGroupMorphism(A_p, A_p, gensA_p, im_gens) # For some reason, this does not always work.
            except RuntimeError:
                if A_p.order() == 1:
                    from sage.all import Hom
                    h = Hom(A_p, A_p).identity()
                else:
                    raise
            b = True
            for j1 in range(n):
                g1 = gensA_p[j1]
                for j2 in range(j1):
                    g2 = gensA_p[j2]
                    b = (B(g1,g2)- B(h(g1),h(g2))).is_integer()
                    if not b:
                        break
                if not b:
                    break
            if b:
                isometries.append(h)
            if verbose:
                print b, im_gens, [type(foo) for foo in im_gens]
                print map(lat_el, list(im_gens))
        ##----------------------------------------------------------------------------------------
        self._p_isometries[p] = isometries
        
        if verbose:
            "Done computing " + str(p) + "-isometries."
        return self._p_isometries[p]
        
    def discriminant_form_p_isometries(self, p, verbose = False, use_orbit_invariants = True):
        """
        Gives isometries for the maximal p-subgroup of the discriminant form of this lattice. The isometries are given
        as isomporphisms of the finite abelian group Z/d_1Z x ... x Z/d_nZ, where the d_i are the maximal
        p-powers dividing the  principal divisors of this lattice.
        If these isometries have been previously computed, the result is recalled.
        
        INPUT:

        'p' -- a prime

        OUTPUT:

        A list of isometries for the maximal p-subgroup of the discriminant form of this lattice
        given as isomorphisms of a finite abelian group.
        
        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: len(L.discriminant_form_p_isometries(2))
            1

            ## False values are used, if they are provided:
            ## --------------------------------------------
            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L._p_isometries = {2 : [L._p_isometries[2][0] for j in range(2)]}
            sage: len(L.discriminant_form_p_isometries(2))
            2
            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L._set_lattice_data('local_isometric_images_of_generators', {2 : [zero_matrix(2,2), zero_matrix(2,2)]})
            sage: len(L._isometric_images_to_isometries())
            2

            ## Values from self._p_isometries are used, if possible.
            ## Copies do not have these values anymore:
            ## ----------------------------------------------------------------------------------------
            sage: L = Lattice(matrix(2 ,2 ,[12, 0, 0, 18]))
            sage: len(L.discriminant_form_p_isometries(2))
            2
            sage: len(L.discriminant_form_p_isometries(3))
            12
            sage: L._get_lattice_data('local_isometric_images_of_generators')
            sage: d = {2 : [identity_matrix(2)], 3 : [identity_matrix(2)]}sage: L._set_lattice_data('local_isometric_images_of_generators', d)
            sage: L._get_lattice_data('local_isometric_images_of_generators') == d
            True
            sage: len(L.discriminant_form_p_isometries(2))
            2
            sage: len(L.discriminant_form_p_isometries(3))
            12
            sage: len(L.copy().discriminant_form_p_isometries(2))
            1
            sage: len(L.copy().discriminant_form_p_isometries(3))
            1
            sage: L._p_isometries = {}
            sage: len(L.discriminant_form_p_isometries(2))
            1
            sage: len(L.discriminant_form_p_isometries(3))
            1 

            ## To safely recompute isometries, do:
            ## -----------------------------------
            sage: L = L.copy()
            sage: L._isometries = None
            sage: L._p_isometries = {}
            sage: L._set_lattice_data('local_isometric_images_of_generators', {})
            sage: L._set_lattice_data('isometric_images_of_generators', None)
            sage: len(L.discriminant_form_p_isometries(2))
            2
            sage: len(L.discriminant_form_p_isometries(3))
            12

        """
        if self._p_isometries == None:
            self._p_isometries = {}
        if self._p_isometries.has_key(p) and False: # The `False` is just here for testing purposes.
            if verbose:
                print str(p) + "-Isometries have been computed before."
            return self._p_isometries[p]
        if self._lattice_data.get('local_isometric_images_of_generators') != None and self._lattice_data['local_isometric_images_of_generators'].has_key(p):
            if verbose:
                print str(p) + "-Isometric images have been computed before."
            return self._isometric_images_to_isometries(p)
        if verbose:
            print "Computing " + str(p) + "-isometries."
        gs, d = self.discriminant_form_gens()
        n = len(d)
        d_p = [p**(d[j].valuation(p)) for j in range(n)]
        d_divided_by_d_p = [Integer(d[j]/d_p[j]) for j in range(n)]
        gs_p = [LatticeSpaceElementOverQQ(self,(Integer(Mod(d_divided_by_d_p[j], d_p[j])**-1)*d_divided_by_d_p[j]*vector(gs[j].list())).list()) for j in range(n)]
        v_p = [vector(g.list()) for g in gs_p]
        qs_p = [g.Q()-floor(g.Q()) for g in gs_p]
        A_p = AbelianGroup(d_p)
        gensA_p = A_p.gens()
        
        def lat_el(a_p):
            b_p = a_p.list()
            if verbose and False:
                print a_p, b_p, v_p, n
            l = (sum(b_p[k]*v_p[k] for k in range(n))).list()
            return LatticeSpaceElementOverQQ(self, l)
        def Q(a):
            return lat_el(a).Q()
        def B(a,b):
            a = A_p(a)
            b = A_p(b)
            return Q(a*b) - Q(a) - Q(b)
        def multiplicities_and_reduced_norms(a):
            m = p**GCD(a.list()).valuation(p)
            a_div_by_m = A_p(map(lambda x: x / m, a.list()))
            red_norm = m * Q(a_div_by_m)
            red_norm = red_norm - floor(red_norm)
            return m, red_norm
        ## orbit invariants (for odd p, we use multiplicities and reduced norms, for p=2, we use Whittaker polynomials)
        @cached_method
        def invariants(a, k):
            if not(use_orbit_invariants):
                return ()
            if p == 2:
                return lat_el(a**(p**k)).Wpoly_invariants(2)
            else:
                return multiplicities_and_reduced_norms(a**(p**k))
        images = dict()
        for k in range(n):
            o = d_p[k]
            q = qs_p[k]
            if not (o,q) in images.keys():
                images[(o,q)] = [a for a in A_p if a.order() == o and (Q(a)-q).is_integer()]
        isometries = []

        ## New loop
        ##---------------------------------------------------------------------------------------
        j = 0
        im_gens = [0 for f in gensA_p]
        possibilities = [images[(f.order(),Q(f)-floor(Q(f)))][:] for f in gensA_p]
        while j >= 0:

            if verbose:
                #print j*" ", j, im_gens
                #print j*" ", possibilities[j]
                print j*" " + str([len(pos) for pos in possibilities]) + "\r",
                sys.stdout.flush()
            if possibilities[j] == []:
                im_gens[j] = 0
                j = j-1
                continue
            else:
                im_gens[j] = possibilities[j].pop()

            ## Checking if orbit invariants coincide (for odd p, we use multiplicities and reduced norms, for p=2, we use multiplicities and Whittaker polynomials):
            b = True
            if p == 2:
                for k in range(gensA_p[j].order().valuation(p)):
                    b = (multiplicities_and_reduced_norms(gensA_p[j]**(p**k))[0] == multiplicities_and_reduced_norms(im_gens[j]**(p**k))[0])
                    if not b:
                        break
                if not b:
                    continue
            for k in range(gensA_p[j].order().valuation(p)):
                b = (invariants(gensA_p[j], k) == invariants(im_gens[j], k))
                if not b:
                    break
            if not b:
                continue

            ## Checking if the j-th image is compatible with the prior ones for an isomorphism:    
            if A_p.subgroup(im_gens[:j+1]).order() != prod(d_p[:j+1]):
                if verbose and False:
                    print j*" ", "Not possible for an isomorphism:"
                    print j*" ", im_gens[:j+1]
                continue

            ## Checking if the j-th image is compatible with the prior ones for an isometry:
            b = True
            for j1 in range(j):
                b = (B(gensA_p[j1],gensA_p[j])- B(im_gens[j1],im_gens[j])).is_integer()
                if not b:
                    if verbose and False:
                        print j*" ", "Not possible for an isometry:"
                        print j*" ", im_gens[:j+1]
                    break
            if not b:
                continue
            else:
                if j < n-1:
                    j = j+1
                    possibilities[j]=images[(gensA_p[j].order(),Q(gensA_p[j])-floor(Q(gensA_p[j])))][:]
                else:
                    # Found an isometry!
                    try:
                        h = AbelianGroupMorphism(A_p, A_p, gensA_p, im_gens[:]) # For some reason, this does not always work.
                    except RuntimeError:
                        if A_p.order() == 1:
                            from sage.all import Hom
                            h = Hom(A_p, A_p).identity()
                        else:
                            raise
                    # Found an isometry!
                    isometries.append(h)
                    if verbose and False:
                        print "Test:", [(h.domain()(h(h.domain().gens()[j]))).list() for j in range(n)]
                        print b, im_gens, [type(foo) for foo in im_gens]
                        print map(lat_el, list(im_gens))
        ##----------------------------------------------------------------------------------------
                
        ## Old loop
        ##---------------------------------------------------------------------------------------
        #for im_gens in itertools.product(*[images[(f.order(),Q(f)-floor(Q(f)))] for f in gensA_p]):
        #    try:
        #        h = AbelianGroupMorphism(A_p, A_p, gensA_p, im_gens) # For some reason, this does not always work.
        #    except RuntimeError:
        #        if A_p.order() == 1:
        #            from sage.all import Hom
        #            h = Hom(A_p, A_p).identity()
        #        else:
        #            raise
        #    b = True
        #    for j1 in range(n):
        #        g1 = gensA_p[j1]
        #        for j2 in range(j1):
        #            g2 = gensA_p[j2]
        #            b = (B(g1,g2)- B(h(g1),h(g2))).is_integer()
        #            if not b:
        #                break
        #        if not b:
        #            break
        #    if b:
        #        isometries.append(h)
        #    if verbose:
        #        print b, im_gens
        #        print map(lat_el, list(im_gens))
        ##----------------------------------------------------------------------------------------

        if verbose and False:
            print p, type(p)
        self._p_isometries[p] = isometries
        
        if verbose:
            "Done computing " + str(p) + "-isometries."
        return self._p_isometries[p]
                   
    def discriminant_form_iterator(self):
        """
        Returns an iterator for representatives of discriminant form of this lattice.
        Since the lattice is Z^n with an even quadratic form, the representatives are
        chosen with coordinates in [0, 1).

        OUTPUT:

        iterator
        
        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: [el for el in L.discriminant_form_iterator()]
            [(0, 0)]
            sage: all([(L.gram_matrix() * el) in ZZ**2 for el in L.discriminant_form_iterator()])
            True


            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: sorted([el for el in L.discriminant_form_iterator()])
            [(0, 0), (1/3, 1/3), (2/3, 2/3)]
            sage: all([(L.gram_matrix() * el) in ZZ**2 for el in L.discriminant_form_iterator()])
            True

            sage: L = Lattice(matrix(2 ,2 ,[-2, 1, 1, 2]))
            sage: sorted([el for el in L.discriminant_form_iterator()])
            [(0, 0), (1/5, 2/5), (2/5, 4/5), (3/5, 1/5), (4/5, 3/5)]
            sage: all([(L.gram_matrix() * el) in ZZ**2 for el in L.discriminant_form_iterator()])
            True
        
            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, 4]))
            sage: sorted([el for el in L.discriminant_form_iterator()])
            [(0, 0),
             (1/7, 5/7),
             (2/7, 3/7),
             (3/7, 1/7),
             (4/7, 6/7),
             (5/7, 4/7),
             (6/7, 2/7)]
            sage: all([(L.gram_matrix() * el) in ZZ**2 for el in L.discriminant_form_iterator()])
            True

            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, -4]))
            sage: sorted([el for el in L.discriminant_form_iterator()])
            [(0, 0),
             (1/9, 7/9),
             (2/9, 5/9),
             (1/3, 1/3),
             (4/9, 1/9),
             (5/9, 8/9),
             (2/3, 2/3),
             (7/9, 4/9),
             (8/9, 2/9)]
            sage: all([(L.gram_matrix() * el) in ZZ**2 for el in L.discriminant_form_iterator()])
            True

            sage: L = Lattice(matrix(2 ,2 ,[-2, 1, 1, 4]))
            sage: sorted([el for el in L.discriminant_form_iterator()])
            [(0, 0),
             (1/9, 2/9),
             (2/9, 4/9),
             (1/3, 2/3),
             (4/9, 8/9),
             (5/9, 1/9),
             (2/3, 1/3),
             (7/9, 5/9),
             (8/9, 7/9)]
            sage: all([(L.gram_matrix() * el) in ZZ**2 for el in L.discriminant_form_iterator()])
            True
        
        """
        D, U, V = self.smith_form()
        d = D.diagonal()
        v = V.columns()
        it1 = itertools.product(*[range(d[x]) for x in range(len(d))])
        it2 = itertools.imap(lambda x: tuple(sum(((x[k]*v[k]) % d[k])/d[k] for k in range(len(d)))), it1)
        it3 = itertools.imap(lambda x: [k - floor(k) for k in x], it2)
        it4 = itertools.imap(lambda x: LatticeSpaceElementOverQQ(self, x), it3)
        return it4
        
    def local_normal_form(self, p):
        """
        Returns the Gram matrix of a locally integrally equivalent quadratic form over
        the p-adic integers Z_p which gives the Jordan decomposition,
        a change of basis proving the equivalence and the inverse of this
        change of basis.
        The Jordan components are written as sums of blocks of size <= 2 and
        are arranged by increasing scale, and then by increasing norm.
        (This is equivalent to saying that we put the 1x1 blocks before
        the 2x2 blocks in each Jordan component.)
        If p=2 the even 2-adic blocks of type I
        will be put in front of those of type II.
        If p=2 and taking 2-adic roots is necessary, the precision of the 2-adic
        ring Zp(2, prec) will be chosen to be roughly 3 times the 2-order of the
        level of the quadratic form plus 10.

        If this computation has been done before, the result is recalled.
        Else the result is stored. The computation itself is done by
        self._local_normal_form(p, sorted_by_type = True, prec = None).

        INPUT:
            `p` -- a positive prime number

        OUTPUT:
            a matrix over ZZ, two matrizes over QQ or Zp(2, prec)

        WARNING:  Currently this only works for quadratic forms defined over ZZ.

        EXAMPLES::

            sage: L = Lattice(ZZ, 2, [10,4,1])
            sage: L.local_normal_form(5)
            (
            [ 2  0]  [ 0  1]  [2 1]
            [ 0 12], [ 1 -2], [1 0]
            )
            sage: Q_Jordan == L.Q.local_normal_form(5).matrix()
            True
            sage: L = Lattice(ZZ, 2, [10,4,1])
            sage: L.local_normal_form(5)
            (
            [ 2  0]  [ 0  1]  [2 1]
            [ 0 12], [ 1 -2], [1 0]
            )
            sage: Q_Jordan, S, S_inv = L.local_normal_form(5)
            sage: Q_Jordan == L.Q.local_normal_form(5).matrix()
            True
            sage: S.transpose() * L.gram_matrix() * S == Q_Jordan
            True
            sage: S_inv.transpose() * Q_Jordan * S_inv == L.gram_matrix()
            True

        ::

            sage: L.local_normal_form(3)
            (
            [20  0]  [ 1 -1]  [  1 1/5]
            [ 0 30], [ 0  5], [  0 1/5]
            )
            sage: Q_Jordan, S, S_inv = L.local_normal_form(3)
            sage: Q_Jordan == L.Q.local_normal_form(3).matrix()
            True
            sage: S.transpose() * L.gram_matrix() * S == Q_Jordan
            True
            sage: S_inv.transpose() * Q_Jordan * S_inv == L.gram_matrix()
            True

        ::
        
            sage: L.local_normal_form(2)
            (
            [ 2  0]  [ 0  1]  [2 1]
            [ 0 12], [ 1 -2], [1 0]
            )
            sage: Q_Jordan, S, S_inv = L.local_normal_form(2)
            sage: Q_Jordan == L.Q.local_normal_form(2).matrix()
            True
            sage: S.transpose() * L.gram_matrix() * S == Q_Jordan
            True
            sage: S_inv.transpose() * Q_Jordan * S_inv == L.gram_matrix()
            True

        ::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L.local_normal_form(2)
            (
            [0 1]  [1 0]  [1 0]
            [1 0], [0 1], [0 1]
            )

        ::
        
            ## Here we would expect no change of basis, but the simplest formula we
            ## could find for the change of basis has this (in no way harmful) effect.
            ##------------------------------------------------------------------------
            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: L.local_normal_form(2)
            (
            [2 1]  [ 0 -1]  [ 1  1]
            [1 2], [ 1  1], [-1  0]
            )

        ::

            sage: L = Lattice(ZZ, 3, [0, 1, 0, 0, 0, 2])
            sage: L.local_normal_form(2)
            (
            [4 0 0]  [ 0  1  0]  [ 0  0 -1]
            [0 0 1]  [ 0  0  1]  [ 1  0  0]
            [0 1 0], [-1  0  0], [ 0  1  0]
            )

        ::

            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, 4]))
            sage: Q_Jordan, S, S_inv = L.local_normal_form(2)
            sage: Q_Jordan
            [0 1]
            [1 0]
            sage: S
            [  1 + 2 + 2^2 + 2^3 + 2^6 + 2^7 + O(2^8)                   2 + 2^4 + 2^5 + O(2^8)]
            [              1 + 2 + 2^5 + 2^6 + O(2^9) 1 + 2^2 + 2^3 + 2^4 + 2^7 + 2^8 + O(2^9)]
            sage: S_inv
            [                      1 + O(2^8)     2 + 2^2 + 2^5 + 2^7 + O(2^8)]
            [                      1 + O(2^8) 1 + 2 + 2^3 + 2^4 + 2^6 + O(2^8)]
            sage: S.transpose() * L.gram_matrix() * S
            [    O(2^8) 1 + O(2^8)]
            [1 + O(2^8)     O(2^8)]
            sage: S_inv.transpose() * Q_Jordan * S_inv
            [  2 + O(2^8)   1 + O(2^8)]
            [  1 + O(2^8) 2^2 + O(2^8)]
            sage: S.transpose() * L.gram_matrix() * S == Q_Jordan
            True
            sage: S_inv.transpose() * Q_Jordan * S_inv == L.gram_matrix()
            True

        ::

            sage: L = Lattice(matrix(2 ,2 ,[2, 3, 3, 2]))
            sage: Q_Jordan, S, S_inv = L.local_normal_form(2)
            sage: Q_Jordan
            [2 1]
            [1 2]
            sage: S
            [        2^3 + 2^5 + 2^7 + O(2^8) 1 + 2 + 2^2 + 2^5 + 2^7 + O(2^8)]
            [1 + 2 + 2^3 + 2^4 + 2^5 + O(2^9) 1 + 2 + 2^3 + 2^4 + 2^5 + O(2^9)]
            sage: S_inv
            [                                        1 + O(2^8)             1 + 2 + 2^3 + 2^4 + 2^5 + 2^6 + O(2^8)]
            [1 + 2 + 2^2 + 2^3 + 2^4 + 2^5 + 2^6 + 2^7 + O(2^8)                     2^3 + 2^4 + 2^5 + 2^6 + O(2^8)]
            sage: S.transpose() * L.gram_matrix() * S
            [2 + O(2^8) 1 + O(2^8)]
            [1 + O(2^8) 2 + O(2^8)]
            sage: S_inv.transpose() * Q_Jordan * S_inv
            [    2 + O(2^2) 1 + 2 + O(2^3)]
            [1 + 2 + O(2^3)     2 + O(2^6)]
            sage: S.transpose() * L.gram_matrix() * S == Q_Jordan
            True
            sage: S_inv.transpose() * Q_Jordan * S_inv == L.gram_matrix()
            True

        ::

            ## This example shows why we use
            ##
            ##     inverse_change_of_basis = change_of_basis.det()**-1 * change_of_basis.adjoint()
            ##
            ## instead of
            ##
            ##     inverse_change_of_basis = change_of_basis**-1
            ##
            ## for non exact rings (i.e. in the 2-adic case if necessary).
            ##------------------------------------------------------------------------------------
            sage: m = matrix([
            ....:     [ -2, -43,  26,  -9,  -1,  -1,  -2,   1,   2,   2],
            ....:     [-43,  10,   2,  -1,  -5,  -1,  -1,   7,  -1,   0],
            ....:     [ 26,   2,   0,  -2,   0,  -2,  -3,  -3,  -8,  -2],
            ....:     [ -9,  -1,  -2,  -2,  -1,   2,  -7,  -2,   0,   1],
            ....:     [ -1,  -5,   0,  -1,   0,  -8,  -6,   0,  -3,  -2],
            ....:     [ -1,  -1,  -2,   2,  -8,  -4,   5,  -3,  -7,  -1],
            ....:     [ -2,  -1,  -3,  -7,  -6,   5,   4,  -2,  -3,   2],
            ....:     [  1,   7,  -3,  -2,   0,  -3,  -2,   4,   1,   4],
            ....:     [  2,  -1,  -8,   0,  -3,  -7,  -3,   1,  -2,   7],
            ....:     [  2,   0,  -2,   1,  -2,  -1,   2,   4,   7,  36]
            ....: ])
            sage: L = Lattice(m)
            sage: Q_Jordan, S, S_inv = L.local_normal_form(2)
            sage: S.det()
            1 + 2^2 + 2^3 + 2^5 + 2^6 + O(2^8)
            sage: S.is_invertible()
            True
            sage: S**-1
            Traceback (most recent call last):
            ...
            ZeroDivisionError: input matrix must be nonsingular
            sage: S * S_inv == identity_matrix(S.base_ring(), S.ncols())
            True
            sage: S.transpose() * L.gram_matrix() * S == Q_Jordan
            True
            sage: S_inv.transpose() * Q_Jordan * S_inv == L.gram_matrix()
            True

        """
        if self._lattice_data.get('local_normal_forms') == None:
            self._lattice_data['local_normal_forms'] = {}
        if self._lattice_data['local_normal_forms'].has_key(p):
            lnf, change_of_basis, inverse_change_of_basis = copy.copy(self._lattice_data['local_normal_forms'][p])
        else:
            Q_Jordan, change_of_basis = self._local_normal_form(p, sorted_by_type = True, prec = None)
            lnf = Q_Jordan.Hessian_matrix()
            if change_of_basis.base_ring().is_exact():
                inverse_change_of_basis = change_of_basis**-1
            else:
                inverse_change_of_basis = change_of_basis.det()**-1 * change_of_basis.adjoint()
            
            self._lattice_data['local_normal_forms'][p] = copy.copy((lnf, change_of_basis, inverse_change_of_basis))
        return lnf, change_of_basis, inverse_change_of_basis

    def _local_normal_form(self, p, sorted_by_type=True, prec=None):
        """
        Returns the a locally integrally equivalent quadratic form over
        the p-adic integers Z_p which gives the Jordan decomposition.  The
        Jordan components are written as sums of blocks of size <= 2 and
        are arranged by increasing scale, and then by increasing norm.
        (This is equivalent to saying that we put the 1x1 blocks before
        the 2x2 blocks in each Jordan component.)
        If p=2 and `sorted_by_type` is true, the even 2-adic blocks of type I
        will be put in front of those of type II.
        If p=2 and no precision (prec) is given, the precision will be chosen
        to be 3 times the 2-order of the level of the quadratic form plus 10.

        INPUT:
            `p` -- a positive prime number

            `sorted_by_type` -- (default: True) a boolean

            `prec` -- (default: None) the precision of the 2-adic change of basis

        OUTPUT:
            a quadratic form over ZZ, the corrsponding change of basis (a matrizes over QQ or Zp(2, prec))

        WARNING:  Currently this only works for quadratic forms defined over ZZ.

        EXAMPLES::

            sage: L = Lattice(ZZ, 2, [10,4,1])
            sage: Q_Jordan, S = L._local_normal_form(5)
            sage: S_inv = S**-1
            sage: Q_Jordan
            Quadratic form in 2 variables over Integer Ring with coefficients: 
            [ 1 0 ]
            [ * 6 ]
            sage: Q_Jordan == L.Q.local_normal_form(5)
            True
            sage: S.transpose() * L.gram_matrix() * S == Q_Jordan.matrix()
            True
            sage: S_inv.transpose() * Q_Jordan.matrix() * S_inv == L.gram_matrix()
            True

        ::

            sage: Q_Jordan, S = L._local_normal_form(3)
            sage: S_inv = S**-1
            sage: Q_Jordan
            Quadratic form in 2 variables over Integer Ring with coefficients: 
            [ 10 0 ]
            [ * 15 ]
            sage: Q_Jordan == L.Q.local_normal_form(3)
            True
            sage: S.transpose() * L.gram_matrix() * S == Q_Jordan.matrix()
            True
            sage: S_inv.transpose() * Q_Jordan.matrix() * S_inv == L.gram_matrix()
            True

        ::
        
            sage: Q_Jordan, S = L._local_normal_form(2)
            sage: S_inv = S**-1
            sage: Q_Jordan
            Quadratic form in 2 variables over Integer Ring with coefficients: 
            [ 1 0 ]
            [ * 6 ]
            sage: Q_Jordan == L.Q.local_normal_form(2)
            True
            sage: S.transpose() * L.gram_matrix() * S == Q_Jordan.matrix()
            True
            sage: S_inv.transpose() * Q_Jordan.matrix() * S_inv == L.gram_matrix()
            True

        ::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: Q_Jordan, S = L._local_normal_form(2)
            sage: Q_Jordan
            Quadratic form in 2 variables over Integer Ring with coefficients: 
            [ 0 1 ]
            [ * 0 ]
            sage: S
            [1 0]
            [0 1]

        ::

            sage: L = Lattice(ZZ, 3, [0, 1, 0, 0, 0, 2])
            sage: Q_Jordan, S = L._local_normal_form(2)
            sage: Q_Jordan
            Quadratic form in 3 variables over Integer Ring with coefficients: 
            [ 2 0 0 ]
            [ * 0 1 ]
            [ * * 0 ]
            sage: S
            [ 0  1  0]
            [ 0  0  1]
            [-1  0  0]

        ::

            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, 4]))
            sage: Q_Jordan, S = L._local_normal_form(2)
            sage: Q_Jordan
            Quadratic form in 2 variables over Integer Ring with coefficients: 
            [ 0 1 ]
            [ * 0 ]
            sage: S
            [  1 + 2 + 2^2 + 2^3 + 2^6 + 2^7 + O(2^8)                   2 + 2^4 + 2^5 + O(2^8)]
            [              1 + 2 + 2^5 + 2^6 + O(2^9) 1 + 2^2 + 2^3 + 2^4 + 2^7 + 2^8 + O(2^9)]
            sage: S_inv = S**-1
            sage: S_inv
            [                      1 + O(2^8)     2 + 2^2 + 2^5 + 2^7 + O(2^8)]
            [                      1 + O(2^8) 1 + 2 + 2^3 + 2^4 + 2^6 + O(2^8)]
            sage: S.transpose() * L.gram_matrix() * S
            [    O(2^8) 1 + O(2^8)]
            [1 + O(2^8)     O(2^8)]
            sage: S.transpose() * L.gram_matrix() * S == Q_Jordan.matrix()
            True
            sage: S_inv.transpose() * Q_Jordan.matrix() * S_inv
            [  2 + O(2^8)   1 + O(2^8)]
            [  1 + O(2^8) 2^2 + O(2^8)]
            sage: S_inv.transpose() * Q_Jordan.matrix() * S_inv == L.gram_matrix()
            True

        ::

            sage: L = Lattice(matrix(2 ,2 ,[2, 3, 3, 2]))
            sage: Q_Jordan, S = L._local_normal_form(2)
            sage: Q_Jordan
            Quadratic form in 2 variables over Integer Ring with coefficients: 
            [ 1 1 ]
            [ * 1 ]
            sage: S
            [        2^3 + 2^5 + 2^7 + O(2^8) 1 + 2 + 2^2 + 2^5 + 2^7 + O(2^8)]
            [1 + 2 + 2^3 + 2^4 + 2^5 + O(2^9) 1 + 2 + 2^3 + 2^4 + 2^5 + O(2^9)]
            sage: S_inv = S**-1
            sage: S_inv
            [                      1 + O(2^2)       1 + 2 + 2^3 + 2^4 + O(2^5)]
            [1 + 2 + 2^2 + 2^3 + 2^4 + O(2^5)   2^3 + 2^4 + 2^5 + 2^6 + O(2^8)]
            sage: S.transpose() * L.gram_matrix() * S
            [2 + O(2^8) 1 + O(2^8)]
            [1 + O(2^8) 2 + O(2^8)]
            sage: S.transpose() * L.gram_matrix() * S == Q_Jordan.matrix()
            True
            sage: S_inv.transpose() * Q_Jordan.matrix() * S_inv
            [    2 + O(2^2) 1 + 2 + O(2^3)]
            [1 + 2 + O(2^3)     2 + O(2^6)]
            sage: S_inv.transpose() * Q_Jordan.matrix() * S_inv == L.gram_matrix()
            True

        ::

            ## This example checks that the base ring of the change of basis is changed in a correct manner
            ##---------------------------------------------------------------------------------------------
            sage: m = matrix([
            ....:     [ -2,   3,   0,  -2,  -1,  26,  -3,  -6],
            ....:     [  3,  -2,   0,   0,   5,  -2,   1, -20],
            ....:     [  0,   0,   0,  -5,  -1, -18,   1,   5],
            ....:     [ -2,   0,  -5,   2,   0,  -6,  11,   0],
            ....:     [ -1,   5,  -1,   0,   0,   3,  -3,   1],
            ....:     [ 26,  -2, -18,  -6,   3,  -8,   0,  -7],
            ....:     [ -3,   1,   1,  11,  -3,   0,   0,  -5],
            ....:     [ -6, -20,   5,   0,   1,  -7,  -5,   2]
            ....: ])
            sage: L = Lattice(m)
            sage: Q_Jordan, S = L._local_normal_form(2)
            sage: S_inv = S**-1
            sage: S.transpose() * L.gram_matrix() * S == Q_Jordan.matrix()
            True
            sage: S_inv.transpose() * Q_Jordan.matrix() * S_inv == L.gram_matrix()
            True
        
        """
        ## Sanity Checks
        if (self.base_ring() != IntegerRing()):
            raise NotImplementedError, "Oops!  This currently only works for quadratic forms defined over IntegerRing(). =("
        if not ((p>=2) and is_prime(p)):
            raise TypeError, "Oops!  p is not a positive prime number. =("

        if (p==2) and not(prec):
            ## This precision should be enough for the (exact!) computation of local Whittaker functions
            ## but could be further optimized!
            prec = 3 * valuation(self.level(), 2) + 10
            
        ## Some useful local variables
        Q = copy.deepcopy(self.Q)
        Q.__init__(self.Q.base_ring(), self.dim(), self.Q.coefficients())
        ## The basis transition matrix (over Zp)
        S = identity_matrix(QQ, self.dim())
        shift=0

        ## Prepare the final form to return
        Q_Jordan = copy.deepcopy(self.Q)
        Q_Jordan.__init__(self.Q.base_ring(), 0)

        while Q.dim() > 0:
            n = Q.dim()

            ## Step 1: Find the minimally p-divisible matrix entry, preferring diagonals
            ## -------------------------------------------------------------------------
            (min_i, min_j) = Q.find_entry_with_minimal_scale_at_prime(p)
            if min_i == min_j:
                min_val = valuation(2 * Q[min_i, min_j], p)
            else:
                min_val = valuation(Q[min_i, min_j], p)

            ## Error if we still haven't seen non-zero coefficients!
            if (min_val == Infinity):
                raise RuntimeError, "Oops!  The original matrix is degenerate. =("


            ## Step 2: Arrange for the upper leftmost entry to have minimal valuation
            ## ----------------------------------------------------------------------
            if (min_i == min_j):
                block_size = 1
                Q.swap_variables(0, min_i, in_place = True)
                #S = S * elementary_matrix(ZZ,self.dim(), row1=shift, row2=min_i+shift)
                S.swap_columns(shift, min_i + shift)
            else:
                ## Work in the upper-left 2x2 block, and replace it by its p-adic equivalent form  
                Q.swap_variables(0, min_i, in_place = True)
                Q.swap_variables(1, min_j, in_place = True)
                #S = S * elementary_matrix(ZZ,self.dim(), row1=shift, row2=min_i+shift)
                #S = S * elementary_matrix(ZZ,self.dim(), row1=1+shift, row2=min_j+shift)
                S.swap_columns(shift, min_i + shift)
                S.swap_columns(1 + shift, min_j + shift)

                ## 1x1 => make upper left the smallest
                if (p != 2):
                    block_size = 1;
                    Q.add_symmetric(1, 0, 1, in_place = True)
                    #S = S * elementary_matrix(ZZ,self.dim(), row1=1+shift, row2=0+shift, scale=1)
                    S.add_multiple_of_column(shift, 1 + shift, 1)
                ## 2x2 => replace it with the appropriate 2x2 matrix
                else: 
                    block_size = 2

            ## DIAGNOSTIC
            #print "\n Finished Step 2 \n";
            #print "\n Q is: \n" + str(Q)  + "\n";
            #print "  p is: " + str(p) 
            #print "  min_val is: " + str( min_val)
            #print "  block_size is: " + str(block_size)
            #print "\n Starting Step 3 \n"

            ## Step 3: Clear out the remaining entries
            ##  ---------------------------------------
            min_scale = p ** min_val                             ## This is the minimal valuation of the Hessian matrix entries.

            ##DIAGNOSTIC
            #print "Starting Step 3:"
            #print "----------------"
            #print "  min_scale is: " + str(min_scale)


            ## Perform cancellation over Z by ensuring divisibility
            if (block_size == 1):
                #print "Block size 1"
                a = 2 * Q[0,0]
                for j in range(block_size, n):
                    b = Q[0, j]
                    g = GCD(a, b)

                    ## DIAGNSOTIC
                    #print "Cancelling from a 1x1 block:"
                    #print "----------------------------"
                    #print "  Cancelling entry with index (" + str(shift) + ", " + str(j) + ")"
                    #print "  entry = " + str(b)
                    #print "  gcd = " + str(g)
                    #print "  a = " + str(a)
                    #print "  b = " + str(b)
                    #print "  a/g = " + str(a/g) + "   (used for stretching)"
                    #print "  -b/g = " + str(-b/g) + "   (used for cancelling)"

                    ## Sanity Check:  a/g is a p-unit
                    if valuation (g, p) != valuation(a, p):
                        raise RuntimeError, "Oops!  We have a problem with our rescaling not preserving p-integrality!"

                    Q.multiply_variable(ZZ(a/g), j, in_place = True)   ## Ensures that the new b entry is divisible by a
                    #S = S * elementary_matrix(ZZ,self.dim(), row1=j+shift, scale=ZZ(a/g))
                    S.rescale_col(j + shift, ZZ(a/g))
                    
                    Q.add_symmetric(ZZ(-b/g), j, 0, in_place = True)  ## Performs the cancellation
                    #S = S * elementary_matrix(ZZ,self.dim(), row1=shift, row2=j+shift, scale=ZZ(-b/g))
                    S.add_multiple_of_column(j + shift, shift, ZZ(-b/g))

            elif (block_size == 2):

                a1 = 2 * Q[0,0]
                a2 = Q[0, 1]
                b1 = Q[1, 0]      ## This is the same as a2
                b2 = 2 * Q[1, 1]

                big_det = (a1*b2 - a2*b1) 
                small_det = big_det / (min_scale * min_scale)

                #print Q
                ## Cancels out the rows/columns of the 2x2 block
                for j in range(block_size, n):
                    a = Q[0, j]
                    b = Q[1, j]

                    ## Ensures an integral result (scale jth row/column by big_det)
                    Q.multiply_variable(big_det, j, in_place = True)
                    #S = S * elementary_matrix(ZZ,self.dim(), row1=j+shift, scale=big_det)
                    S.rescale_col(j + shift, big_det)
                    
                    ## Performs the cancellation (by producing -big_det * jth row/column)
                    Q.add_symmetric(ZZ(-(a*b2 - b*a2)), j, 0, in_place = True)
                    #S = S*elementary_matrix(ZZ,self.dim(), row1=shift, row2=j+shift, scale=ZZ(-(a*b2 - b*a2)))
                    S.add_multiple_of_column(j + shift, shift, ZZ(-(a*b2 - b*a2)))
                    
                    Q.add_symmetric(ZZ(-(-a*b1 + b*a1)), j, 1, in_place = True)
                    #S = S*elementary_matrix(ZZ,self.dim(), row1=1+shift, row2=j+shift, scale=ZZ(-(-a*b1 + b*a1)))
                    S.add_multiple_of_column(j + shift, 1 + shift, ZZ(-(-a*b1 + b*a1)))
                    
                    ## Now remove the extra factor (non p-unit factor) in big_det we introduced above
                    Q.divide_variable(ZZ(min_scale * min_scale), j, in_place = True)
                    #S = S*elementary_matrix(QQ,self.dim(), row1=j+shift, scale=QQ(1/(min_scale * min_scale)))
                    S.rescale_col(j + shift, QQ(min_scale * min_scale)**-1)
                    
                ## DIAGNOSTIC
                #print "Cancelling out a 2x2 block:"
                #print "---------------------------"
                #print "  a1 = " + str(a1)
                #print "  a2 = " + str(a2)
                #print "  b1 = " + str(b1)
                #print "  b2 = " + str(b2)
                #print "  big_det = " + str(big_det)
                #print "  min_scale = " + str(min_scale)            
                #print "  small_det = " + str(small_det)
                #print "  shift = " + str(shift)
                #print "  S = " + str(S)
                #print "  Q = \n", Q
   
                ## Uses Cassels's proof to replace the remaining 2 x 2 block
                
                a1 = a1 / min_scale
                a2 = a2 / min_scale
                b2 = b2 / min_scale
                Rng = QQ
                
                if (((1 + small_det) % 8) == 0):

                    Q[0, 0] = 0
                    Q[1, 1] = 0
                    Q[0, 1] = min_scale

                    ## Compute the appropriate change of basis
                    if a1 == 0:
                        little_matrix = matrix(QQ, 2, 2, [1/a2, -1 * b2 / (2 * a2), 0, 1])
                    else:
                        if a1 % 4 == 0:
                            if b2 % 4 == 0:
                                little_matrix = matrix(QQ, 2, 2, [1, 0, 1, 1])
                                h11 = a1 + 2*a2 + b2 
                                h12 = a2 + b2
                                h22 = b2
                            else:
                                little_matrix = matrix(QQ, 2, 2, [0, 1, 1, 0])
                                h11 = b2
                                h12 = a2
                                h22 = a1
                        else:
                            little_matrix = matrix(QQ, 2, 2, [1, 0, 0, 1])
                            h11 = a1
                            h12 = a2
                            h22 = b2
                        cc = -1 * small_det
                        if cc.is_square():
                            c = (-1 * small_det).sqrt()
                        else:
                            Rng = Zp(2, prec = prec)
                            c = Rng(-1 * small_det).sqrt()
                            
                        little_matrix = little_matrix * matrix(Rng, 2, 2, [(1 - h12 / c) / 2, (1 + h12 / c) / h11, h11 / (2 * c), -1 / c])
                        
                elif (((5 + small_det) % 8) == 0):
                    
                    Q[0, 0] = min_scale
                    Q[1, 1] = min_scale
                    Q[0, 1] = min_scale
                    
                    if (a1 - 10) % 16 == 0 or (a1 - 14) % 16 == 0:
                        little_matrix = matrix(QQ, 2, 2, [1, 0, 4, 1])
                        h11 = a1 + 8*a2 + 16*b2 
                        h12 = a2 + 4*b2
                        h22 = b2
                    else:
                        little_matrix = matrix(QQ, 2, 2, [1, 0, 0, 1])
                        h11 = a1
                        h12 = a2
                        h22 = b2
                    if (h11 - 2) % 16 == 0:
                        cc = 3 * h11 / (2 * small_det)
                        if cc.is_square():
                            c = cc.sqrt()
                        else:
                            Rng = Zp(2, prec = prec)
                            c = Rng(cc).sqrt()
                            
                        dd = 2*h11 - cc*small_det
                        if dd.is_square():
                            d = dd.sqrt()
                        else:
                            Rng = Zp(2, prec = prec)
                            d = Rng(dd).sqrt()

                        little_matrix = little_matrix * matrix(Rng, 2, 2, [(d - c * h12) / h11, (-1 * c * h12 - d) / h11, c, c])

                    elif (h11 - 6) % 16 == 0:
                        cc = h11 / (2 * small_det)
                        if cc.is_square():
                            c = cc.sqrt()
                        else:
                            Rng = Zp(2, prec = prec)
                            c = Rng(cc).sqrt()

                        dd = 2*h11 - cc*small_det
                        if dd.is_square():
                            d = dd.sqrt()
                        else:
                            Rng = Zp(2, prec = prec)
                            d = Rng(dd).sqrt()

                        little_matrix = little_matrix * matrix(Rng, 2, 2, [(d - c * h12) / h11, (d + c * h12) / h11, c, -1 * c])
                        
                    else:
                        raise RuntimeError, "Error in LocalNormal: Impossible behavior for a 2x2 block! \n"
                    
                else:
                    raise RuntimeError, "Error in LocalNormal: Impossible behavior for a 2x2 block! \n"
                    
                #big_matrix = identity_matrix(Rng, self.dim())
                #big_matrix[shift : shift +2, shift : shift +2] = little_matrix
                #S = S * big_matrix
                Rng = little_matrix.base_ring()
                if Rng != QQ:
                    S = S.change_ring(Rng)
                S[:, shift:shift+2] = S[:, shift:shift+2] * little_matrix
                
                
            ## Check that the cancellation worked, extract the upper-left block, and trim Q to handle the next block.
            for i in range(block_size):
                for j in range(block_size, n):
                    if Q[i,j] != 0:
                        raise RuntimeError, "Oops!  The cancellation didn't work properly at entry (" + str(i) + ", " + str(j) + ")."
            #Q_Jordan = Q_Jordan + Q.extract_variables(range(block_size)) #This uses lots of memory!
            if block_size == 1:
                Q_Jordan = Q_Jordan + QuadraticForm(ZZ, 1, [Q[0,0]])
            else:
                Q_Jordan = Q_Jordan + QuadraticForm(ZZ, 2, [Q[0,0], Q[0,1], Q[1,1]])
            Q = Q.extract_variables(range(block_size, n))
            shift=shift+block_size

        #Sorting the blocs by their type in the 2-adic case
        if sorted_by_type and p == 2:
            n = Q_Jordan.dim()
            big_block_variables = [x for x in range(n-1) if Q_Jordan[x, x+1] != 0]
            big_block_first_variables = big_block_variables[:]
            for x in range(len(big_block_variables)):
                big_block_variables.insert(2*x + 1, big_block_variables[2*x] + 1)
            
            type_I_block_variables = [x for x in big_block_variables if Q_Jordan[x,x] == 0]
            type_II_block_variables = [x for x in big_block_variables if not(x in type_I_block_variables)]
            small_block_variables = [x for x in range(n) if not(x in big_block_variables)]
            new_variable_order = small_block_variables + type_I_block_variables + type_II_block_variables

            Q = copy.deepcopy(Q_Jordan)
            Q.__init__(Q_Jordan.base_ring(), Q_Jordan.dim(), [0 for x in range(Integer(n*(n+1))/2)])
            
            oldS = S[:,:]
            
            for x in range(n):
                newx = new_variable_order[x]
                if newx in big_block_first_variables:

                    Q[x,x] = Q_Jordan[newx, newx]
                    Q[x,x+1] = Q_Jordan[newx, newx+1]
                    Q[x+1,x+1] = Q_Jordan[newx+1, newx+1]
                    
                elif newx in small_block_variables:
                    
                    Q[x,x] = Q_Jordan[newx,newx]

                S[:, x] = oldS[:, newx]
                
            return Q, S
            
        return Q_Jordan, S

    def _local_normal_form_old(self, p, sorted_by_type=True, prec=None):
        """
        Returns the a locally integrally equivalent quadratic form over
        the p-adic integers Z_p which gives the Jordan decomposition.  The
        Jordan components are written as sums of blocks of size <= 2 and
        are arranged by increasing scale, and then by increasing norm.
        (This is equivalent to saying that we put the 1x1 blocks before
        the 2x2 blocks in each Jordan component.)
        If p=2 and `sorted_by_type` is true, the even 2-adic blocks of type I
        will be put in front of those of type II.
        If p=2 and no precision (prec) is given, the precision will be chosen
        to be 3 times the 2-order of the level of the quadratic form plus 10.

        INPUT:
            `p` -- a positive prime number

            `sorted_by_type` -- (default: True) a boolean

            `prec` -- (default: None) the precision of the 2-adic change of basis

        OUTPUT:
            a quadratic form over ZZ, the corrsponding change of basis (a matrizes over QQ or Zp(2, prec))

        WARNING:  Currently this only works for quadratic forms defined over ZZ.

        EXAMPLES::

            sage: L = Lattice(ZZ, 2, [10,4,1])
            sage: Q_Jordan, S = L._local_normal_form_old(5)
            sage: S_inv = S**-1
            sage: Q_Jordan
            Quadratic form in 2 variables over Integer Ring with coefficients: 
            [ 1 0 ]
            [ * 6 ]
            sage: Q_Jordan == L.Q.local_normal_form(5)
            True
            sage: S.transpose() * L.gram_matrix() * S == Q_Jordan.matrix()
            True
            sage: S_inv.transpose() * Q_Jordan.matrix() * S_inv == L.gram_matrix()
            True

        ::

            sage: Q_Jordan, S = L._local_normal_form_old(3)
            sage: S_inv = S**-1
            sage: Q_Jordan
            Quadratic form in 2 variables over Integer Ring with coefficients: 
            [ 10 0 ]
            [ * 15 ]
            sage: Q_Jordan == L.Q.local_normal_form(3)
            True
            sage: S.transpose() * L.gram_matrix() * S == Q_Jordan.matrix()
            True
            sage: S_inv.transpose() * Q_Jordan.matrix() * S_inv == L.gram_matrix()
            True

        ::
        
            sage: Q_Jordan, S = L._local_normal_form_old(2)
            sage: S_inv = S**-1
            sage: Q_Jordan
            Quadratic form in 2 variables over Integer Ring with coefficients: 
            [ 1 0 ]
            [ * 6 ]
            sage: Q_Jordan == L.Q.local_normal_form(2)
            True
            sage: S.transpose() * L.gram_matrix() * S == Q_Jordan.matrix()
            True
            sage: S_inv.transpose() * Q_Jordan.matrix() * S_inv == L.gram_matrix()
            True

        ::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: Q_Jordan, S = L._local_normal_form_old(2)
            sage: Q_Jordan
            Quadratic form in 2 variables over Integer Ring with coefficients: 
            [ 0 1 ]
            [ * 0 ]
            sage: S
            [1 0]
            [0 1]

        ::

            sage: L = Lattice(ZZ, 3, [0, 1, 0, 0, 0, 2])
            sage: Q_Jordan, S = L._local_normal_form_old(2)
            sage: Q_Jordan
            Quadratic form in 3 variables over Integer Ring with coefficients: 
            [ 2 0 0 ]
            [ * 0 1 ]
            [ * * 0 ]
            sage: S
            [ 0  1  0]
            [ 0  0  1]
            [-1  0  0]

        ::

            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, 4]))
            sage: Q_Jordan, S = L._local_normal_form_old(2)
            sage: Q_Jordan
            Quadratic form in 2 variables over Integer Ring with coefficients: 
            [ 0 1 ]
            [ * 0 ]
            sage: S
            [  1 + 2 + 2^2 + 2^3 + 2^6 + 2^7 + O(2^8)                   2 + 2^4 + 2^5 + O(2^8)]
            [              1 + 2 + 2^5 + 2^6 + O(2^9) 1 + 2^2 + 2^3 + 2^4 + 2^7 + 2^8 + O(2^9)]
            sage: S_inv = S**-1
            sage: S_inv
            [                      1 + O(2^8)     2 + 2^2 + 2^5 + 2^7 + O(2^8)]
            [                      1 + O(2^8) 1 + 2 + 2^3 + 2^4 + 2^6 + O(2^8)]
            sage: S.transpose() * L.gram_matrix() * S
            [    O(2^8) 1 + O(2^8)]
            [1 + O(2^8)     O(2^8)]
            sage: S.transpose() * L.gram_matrix() * S == Q_Jordan.matrix()
            True
            sage: S_inv.transpose() * Q_Jordan.matrix() * S_inv
            [  2 + O(2^8)   1 + O(2^8)]
            [  1 + O(2^8) 2^2 + O(2^8)]
            sage: S_inv.transpose() * Q_Jordan.matrix() * S_inv == L.gram_matrix()
            True

        ::

            sage: L = Lattice(matrix(2 ,2 ,[2, 3, 3, 2]))
            sage: Q_Jordan, S = L._local_normal_form_old(2)
            sage: Q_Jordan
            Quadratic form in 2 variables over Integer Ring with coefficients: 
            [ 1 1 ]
            [ * 1 ]
            sage: S
            [        2^3 + 2^5 + 2^7 + O(2^8) 1 + 2 + 2^2 + 2^5 + 2^7 + O(2^8)]
            [1 + 2 + 2^3 + 2^4 + 2^5 + O(2^9) 1 + 2 + 2^3 + 2^4 + 2^5 + O(2^9)]
            sage: S_inv = S**-1
            sage: S_inv
            [                      1 + O(2^2)       1 + 2 + 2^3 + 2^4 + O(2^5)]
            [1 + 2 + 2^2 + 2^3 + 2^4 + O(2^5)   2^3 + 2^4 + 2^5 + 2^6 + O(2^8)]
            sage: S.transpose() * L.gram_matrix() * S
            [2 + O(2^8) 1 + O(2^8)]
            [1 + O(2^8) 2 + O(2^8)]
            sage: S.transpose() * L.gram_matrix() * S == Q_Jordan.matrix()
            True
            sage: S_inv.transpose() * Q_Jordan.matrix() * S_inv
            [    2 + O(2^2) 1 + 2 + O(2^3)]
            [1 + 2 + O(2^3)     2 + O(2^6)]
            sage: S_inv.transpose() * Q_Jordan.matrix() * S_inv == L.gram_matrix()
            True
        
        """
        ## Sanity Checks
        if (self.base_ring() != IntegerRing()):
            raise NotImplementedError, "Oops!  This currently only works for quadratic forms defined over IntegerRing(). =("
        if not ((p>=2) and is_prime(p)):
            raise TypeError, "Oops!  p is not a positive prime number. =("

        if (p==2) and not(prec):
            ## This precision should be enough for the (exact!) computation of local Whittaker functions
            ## but could be further optimized!
            g2 = self.Q.local_genus_symbol(2).canonical_symbol()
            prec = 3 * max(x[0] for x in g2) + 10
            
        ## Some useful local variables
        Q = copy.deepcopy(self.Q)
        Q.__init__(self.Q.base_ring(), self.dim(), self.Q.coefficients())
        ## The basis transition matrix (over Zp)
        S = diagonal_matrix(QQ, self.dim(), [1 for _ in range(self.dim())])
        shift=0

        ## Prepare the final form to return
        Q_Jordan = copy.deepcopy(self.Q)
        Q_Jordan.__init__(self.Q.base_ring(), 0)

        while Q.dim() > 0:
            n = Q.dim()

            ## Step 1: Find the minimally p-divisible matrix entry, preferring diagonals
            ## -------------------------------------------------------------------------
            (min_i, min_j) = Q.find_entry_with_minimal_scale_at_prime(p)
            if min_i == min_j:
                min_val = valuation(2 * Q[min_i, min_j], p)
            else:
                min_val = valuation(Q[min_i, min_j], p)

            ## Error if we still haven't seen non-zero coefficients!
            if (min_val == Infinity):
                raise RuntimeError, "Oops!  The original matrix is degenerate. =("


            ## Step 2: Arrange for the upper leftmost entry to have minimal valuation
            ## ----------------------------------------------------------------------
            if (min_i == min_j):
                block_size = 1
                Q.swap_variables(0, min_i, in_place = True)
                S = S * elementary_matrix(ZZ,self.dim(), row1=shift, row2=min_i+shift)
            else:
                ## Work in the upper-left 2x2 block, and replace it by its p-adic equivalent form  
                Q.swap_variables(0, min_i, in_place = True)
                Q.swap_variables(1, min_j, in_place = True)
                S = S * elementary_matrix(ZZ,self.dim(), row1=shift, row2=min_i+shift)
                S = S * elementary_matrix(ZZ,self.dim(), row1=1+shift, row2=min_j+shift)

                ## 1x1 => make upper left the smallest
                if (p != 2):
                    block_size = 1;
                    Q.add_symmetric(1, 0, 1, in_place = True)
                    S = S * elementary_matrix(ZZ,self.dim(), row1=1+shift, row2=0+shift, scale=1)
                ## 2x2 => replace it with the appropriate 2x2 matrix
                else: 
                    block_size = 2

            ## DIAGNOSTIC
            #print "\n Finished Step 2 \n";
            #print "\n Q is: \n" + str(Q)  + "\n";
            #print "  p is: " + str(p) 
            #print "  min_val is: " + str( min_val)
            #print "  block_size is: " + str(block_size)
            #print "\n Starting Step 3 \n"

            ## Step 3: Clear out the remaining entries
            ##  ---------------------------------------
            min_scale = p ** min_val                             ## This is the minimal valuation of the Hessian matrix entries.

            ##DIAGNOSTIC
            #print "Starting Step 3:"
            #print "----------------"
            #print "  min_scale is: " + str(min_scale)


            ## Perform cancellation over Z by ensuring divisibility
            if (block_size == 1):
                #print "Block size 1"
                a = 2 * Q[0,0]
                for j in range(block_size, n):
                    b = Q[0, j]
                    g = GCD(a, b)

                    ## DIAGNSOTIC
                    #print "Cancelling from a 1x1 block:"
                    #print "----------------------------"
                    #print "  Cancelling entry with index (" + str(shift) + ", " + str(j) + ")"
                    #print "  entry = " + str(b)
                    #print "  gcd = " + str(g)
                    #print "  a = " + str(a)
                    #print "  b = " + str(b)
                    #print "  a/g = " + str(a/g) + "   (used for stretching)"
                    #print "  -b/g = " + str(-b/g) + "   (used for cancelling)"

                    ## Sanity Check:  a/g is a p-unit
                    if valuation (g, p) != valuation(a, p):
                        raise RuntimeError, "Oops!  We have a problem with our rescaling not preserving p-integrality!"

                    Q.multiply_variable(ZZ(a/g), j, in_place = True)   ## Ensures that the new b entry is divisible by a
                    S = S * elementary_matrix(ZZ,self.dim(), row1=j+shift, scale=ZZ(a/g))
                    Q.add_symmetric(ZZ(-b/g), j, 0, in_place = True)  ## Performs the cancellation
                    S = S * elementary_matrix(ZZ,self.dim(), row1=shift, row2=j+shift, scale=ZZ(-b/g))

            elif (block_size == 2):

                a1 = 2 * Q[0,0]
                a2 = Q[0, 1]
                b1 = Q[1, 0]      ## This is the same as a2
                b2 = 2 * Q[1, 1]

                big_det = (a1*b2 - a2*b1) 
                small_det = big_det / (min_scale * min_scale)

                #print Q
                ## Cancels out the rows/columns of the 2x2 block
                for j in range(block_size, n):
                    a = Q[0, j]
                    b = Q[1, j]

                    ## Ensures an integral result (scale jth row/column by big_det)
                    Q.multiply_variable(big_det, j, in_place = True)
                    S = S * elementary_matrix(ZZ,self.dim(), row1=j+shift, scale=big_det)
                    
                    ## Performs the cancellation (by producing -big_det * jth row/column)
                    Q.add_symmetric(ZZ(-(a*b2 - b*a2)), j, 0, in_place = True)
                    S = S*elementary_matrix(ZZ,self.dim(), row1=shift, row2=j+shift, scale=ZZ(-(a*b2 - b*a2)))
                    
                    Q.add_symmetric(ZZ(-(-a*b1 + b*a1)), j, 1, in_place = True)
                    S = S*elementary_matrix(ZZ,self.dim(), row1=1+shift, row2=j+shift, scale=ZZ(-(-a*b1 + b*a1)))
                    
                    ## Now remove the extra factor (non p-unit factor) in big_det we introduced above
                    Q.divide_variable(ZZ(min_scale * min_scale), j, in_place = True)
                    S = S*elementary_matrix(QQ,self.dim(), row1=j+shift, scale=QQ(1/(min_scale * min_scale)))
                    
                ## DIAGNOSTIC
                #print "Cancelling out a 2x2 block:"
                #print "---------------------------"
                #print "  a1 = " + str(a1)
                #print "  a2 = " + str(a2)
                #print "  b1 = " + str(b1)
                #print "  b2 = " + str(b2)
                #print "  big_det = " + str(big_det)
                #print "  min_scale = " + str(min_scale)            
                #print "  small_det = " + str(small_det)
                #print "  shift = " + str(shift)
                #print "  S = " + str(S)
                #print "  Q = \n", Q
   
                ## Uses Cassels's proof to replace the remaining 2 x 2 block
                
                a1 = a1 / min_scale
                a2 = a2 / min_scale
                b2 = b2 / min_scale
                Rng = QQ
                
                if (((1 + small_det) % 8) == 0):

                    Q[0, 0] = 0
                    Q[1, 1] = 0
                    Q[0, 1] = min_scale

                    ## Compute the appropriate change of basis
                    if a1 == 0:
                        little_matrix = matrix(QQ, 2, 2, [1/a2, -1 * b2 / (2 * a2), 0, 1])
                    else:
                        if a1 % 4 == 0:
                            if b2 % 4 == 0:
                                little_matrix = matrix(QQ, 2, 2, [1, 0, 1, 1])
                                h11 = a1 + 2*a2 + b2 
                                h12 = a2 + b2
                                h22 = b2
                            else:
                                little_matrix = matrix(QQ, 2, 2, [0, 1, 1, 0])
                                h11 = b2
                                h12 = a2
                                h22 = a1
                        else:
                            little_matrix = matrix(QQ, 2, 2, [1, 0, 0, 1])
                            h11 = a1
                            h12 = a2
                            h22 = b2
                        cc = -1 * small_det
                        if cc.is_square():
                            c = (-1 * small_det).sqrt()
                        else:
                            Rng = Zp(2, prec = prec)
                            c = Rng(-1 * small_det).sqrt()
                            
                        little_matrix = little_matrix * matrix(Rng, 2, 2, [(1 - h12 / c) / 2, (1 + h12 / c) / h11, h11 / (2 * c), -1 / c])
                        
                elif (((5 + small_det) % 8) == 0):
                    
                    Q[0, 0] = min_scale
                    Q[1, 1] = min_scale
                    Q[0, 1] = min_scale
                    
                    if (a1 - 10) % 16 == 0 or (a1 - 14) % 16 == 0:
                        little_matrix = matrix(QQ, 2, 2, [1, 0, 4, 1])
                        h11 = a1 + 8*a2 + 16*b2 
                        h12 = a2 + 4*b2
                        h22 = b2
                    else:
                        little_matrix = matrix(QQ, 2, 2, [1, 0, 0, 1])
                        h11 = a1
                        h12 = a2
                        h22 = b2
                    if (h11 - 2) % 16 == 0:
                        cc = 3 * h11 / (2 * small_det)
                        if cc.is_square():
                            c = cc.sqrt()
                        else:
                            Rng = Zp(2, prec = prec)
                            c = Rng(cc).sqrt()
                            
                        dd = 2*h11 - cc*small_det
                        if dd.is_square():
                            d = dd.sqrt()
                        else:
                            Rng = Zp(2, prec = prec)
                            d = Rng(dd).sqrt()

                        little_matrix = little_matrix * matrix(Rng, 2, 2, [(d - c * h12) / h11, (-1 * c * h12 - d) / h11, c, c])

                    elif (h11 - 6) % 16 == 0:
                        cc = h11 / (2 * small_det)
                        if cc.is_square():
                            c = cc.sqrt()
                        else:
                            Rng = Zp(2, prec = prec)
                            c = Rng(cc).sqrt()

                        dd = 2*h11 - cc*small_det
                        if dd.is_square():
                            d = dd.sqrt()
                        else:
                            Rng = Zp(2, prec = prec)
                            d = Rng(dd).sqrt()

                        little_matrix = little_matrix * matrix(Rng, 2, 2, [(d - c * h12) / h11, (d + c * h12) / h11, c, -1 * c])
                        
                    else:
                        raise RuntimeError, "Error in LocalNormal: Impossible behavior for a 2x2 block! \n"
                    
                else:
                    raise RuntimeError, "Error in LocalNormal: Impossible behavior for a 2x2 block! \n"
                    
                big_matrix = identity_matrix(Rng, self.dim())
                big_matrix[shift : shift +2, shift : shift +2] = little_matrix
                S = S * big_matrix
                
            ## Check that the cancellation worked, extract the upper-left block, and trim Q to handle the next block.
            for i in range(block_size):
                for j in range(block_size, n):
                    if Q[i,j] != 0:
                        raise RuntimeError, "Oops!  The cancellation didn't work properly at entry (" + str(i) + ", " + str(j) + ")."
            Q_Jordan = Q_Jordan + Q.extract_variables(range(block_size))
            Q = Q.extract_variables(range(block_size, n))
            shift=shift+block_size

        #Sorting the blocs by their type in the 2-adic case
        if sorted_by_type and p == 2:
            n = Q_Jordan.dim()
            big_block_variables = [x for x in range(n-1) if Q_Jordan[x, x+1] != 0]
            big_block_first_variables = big_block_variables[:]
            for x in range(len(big_block_variables)):
                big_block_variables.insert(2*x + 1, big_block_variables[2*x] + 1)
            
            type_I_block_variables = [x for x in big_block_variables if Q_Jordan[x,x] == 0]
            type_II_block_variables = [x for x in big_block_variables if not(x in type_I_block_variables)]
            small_block_variables = [x for x in range(n) if not(x in big_block_variables)]
            new_variable_order = small_block_variables + type_I_block_variables + type_II_block_variables

            Q = copy.deepcopy(Q_Jordan)
            Q.__init__(Q_Jordan.base_ring(), Q_Jordan.dim(), [0 for x in range(Integer(n*(n+1))/2)])
            
            oldS = S[:,:]
            
            for x in range(n):
                newx = new_variable_order[x]
                if newx in big_block_first_variables:

                    Q[x,x] = Q_Jordan[newx, newx]
                    Q[x,x+1] = Q_Jordan[newx, newx+1]
                    Q[x+1,x+1] = Q_Jordan[newx+1, newx+1]
                    
                elif newx in small_block_variables:
                    
                    Q[x,x] = Q_Jordan[newx,newx]

                S[:, x] = oldS[:, newx]
                
            return Q, S
            
        return Q_Jordan, S
        
    @cached_method
    def valuation(self,i,p):
        """
        Gets the p-order of the (i,i)-entry in the diagonalized local normal form if p is odd.
        If p=2, get the 2-order of the of the upper right entry of the block containing the (i,i)-entry.

        INPUT:
            `i` -- an integer in range(self.dim())
        
            `p` -- a positive prime number

        OUTPUT:
            an integer
        
        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L.local_normal_form(2)[0]
            [0 1]
            [1 0]
            sage: L.valuation(0,2)
            0
            sage: L.valuation(1,2)
            0
            sage: L = Lattice(2 * matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L.valuation(0,2)
            1
            sage: L.valuation(1,2)
            1
            sage: L = Lattice(12 * matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L.valuation(0,2)
            2
            sage: L.valuation(1,2)
            2

        ::

            sage: L = Lattice(ZZ, 3, [0, 1, 0, 0, 0, 2])
            sage: L.local_normal_form(2)[0]
            [4 0 0]
            [0 0 1]
            [0 1 0]
            sage: L.valuation(0,2)
            2
            sage: L.valuation(1,2)
            0
            sage: L.valuation(2,2)
            0

        ::

            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: L.local_normal_form(2)[0]
            [2 1]
            [1 2]
            sage: L.valuation(0,2)
            0
            sage: L.valuation(1,2)
            0
            sage: L = Lattice(2 * matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: L.valuation(0,2)
            1
            sage: L.valuation(1,2)
            1
            sage: L = Lattice(12 * matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: L.local_normal_form(2)[0]
            [8 4]
            [4 8]
            sage: L.valuation(0,2)
            2
            sage: L.valuation(0,2) == valuation(4,2)
            True
            sage: L.valuation(1,2)
            2
            sage: L.valuation(1,2) == valuation(4,2)
            True
            sage: L.local_normal_form(3)[0]
            [24  0]
            [ 0 72]
            sage: L.valuation(0,3)
            1
            sage: L.valuation(0,3) == valuation(24,3)
            True
            sage: L.valuation(1,3)
            2
            sage: L.valuation(1,3) == valuation(72,3)
            True           
        
        """
        S=self.local_normal_form(p)[0]
        if p==2:
            if i < S.ncols()-1 and  S[i,i+1]!=0:
                return valuation(S[i,i+1], p)
            if i > 0 and S[i, i-1]!=0:
                return valuation(S[i,i-1], p)
        return valuation(S[i,i],p)
            
    @cached_method
    def unit(self,i,p):
        """
        Gets the p-adic unit (=u) in the factorization of the (i,i)-entry (=2*u*p**e) in the diagonalized local normal form if p is odd.
        If p=2 and the (i,i)-entry is contained in a 2x2-block, return 1. If If the (i,i)-entry (=u*p**e) forms a 1x1 block, return
        the 2-adic unit (=u) in this factorization.

        INPUT:
            `i` -- an integer in range(self.dim())
        
            `p` -- a positive prime number

        OUTPUT:
            an integer
        
        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L.local_normal_form(2)[0]
            [0 1]
            [1 0]
            sage: L.unit(0,2)
            1
            sage: L.unit(1,2)
            1
            sage: L = Lattice(2 * matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L.unit(0,2)
            1
            sage: L.unit(1,2)
            1
            sage: L = Lattice(12 * matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L.local_normal_form(2)[0]
            [0 4]
            [4 0]
            sage: L.unit(0,2)
            1
            sage: L.unit(1,2)
            1

        ::

            sage: L = Lattice(ZZ, 3, [0, 3, 0, 0, 0, 36])
            sage: L.local_normal_form(2)[0]
            [5832    0    0]
            [   0    0    1]
            [   0    1    0]
            sage: L.unit(0,2)
            729
            sage: L.unit(1,2)
            1
            sage: L.unit(2,2)
            1
            sage: L.local_normal_form(3)[0]
            [ 6  0  0]
            [ 0 -6  0]
            [ 0  0 72]
            sage: L.unit(0,3)
            1
            sage: L.unit(1,3)
            -1
            sage: L.unit(2,3)
            4           
        
        """
        S = self.local_normal_form(p)[0]
        if p==2:
            if i < S.ncols()-1 and  S[i,i+1]!=0:
                return 1
            if i > 0 and S[i, i-1]!=0:
                return 1
            return p**(- self.valuation(i, p))*S[i,i]
        else:
            return p**(- self.valuation(i, p))*S[i,i] / 2

    @cached_method
    def p_excess(self, p):
        """
        Return  the p-excess of this lattice for an odd prime p.

        INPUT:    
            `p` -- an odd positive prime number

        OUTPUT:
            an integer
        
        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L.p_excess(3)
            0
            sage: L.p_excess(5)
            0

        ::

            sage: L = Lattice(ZZ, 3, [0, 3, 0, 0, 0, 36])
            sage: L.local_normal_form(3)[0]
            [ 6  0  0]
            [ 0 -6  0]
            [ 0  0 72]
            sage: L.p_excess(3)
            0
            sage: L = Lattice(ZZ, 1, [3])
            sage: L.p_excess(3)
            6
            sage: L = Lattice(ZZ, 1, [-3])
            sage: L.p_excess(3)
            2
            sage: L = Lattice(ZZ, 1, [36])
            sage: L.p_excess(3)
            0
        
        """
        if p==2:
            raise ValueError, "The argument p should be a prime other than 2. Given: {0}".format(p)
        else:
            result = 0
            for j in range(self.dim()):
                result += (p**self.valuation(j,p) - 1) % 8
                if self.valuation(j,p) % 2 != 0 and kronecker_symbol(2 * self.unit(j,p), p) == -1:
                    result += 4
        return result % 8

    @cached_method
    def oddity(self):
        """
        Return the oddity of this lattice.

        OUTPUT:
            an integer
        
        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L.oddity()
            0
        
            sage: L = Lattice(2 * matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L.oddity()
            0
        
            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: L.oddity()
            0
        
            sage: L = Lattice(2 * matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: L.oddity()
            4
        
            sage: L = Lattice(ZZ, 1, [1])
            sage: L.oddity()
            1
        
            sage: L = Lattice(ZZ, 1, [2])
            sage: L.oddity()
            1
        
            sage: L = Lattice(ZZ, 1, [3])
            sage: L.oddity()
            7
        
            sage: L = Lattice(ZZ, 1, [4])
            sage: L.oddity()
            1
        
            sage: L = Lattice(ZZ, 1, [5])
            sage: L.oddity()
            1
        
            sage: L = Lattice(ZZ, 1, [6])
            sage: L.oddity()
            3
        
            sage: L = Lattice(ZZ, 1, [7])
            sage: L.oddity()
            7
        
            sage: L = Lattice(ZZ, 1, [8])
            sage: L.oddity()
            1
        
        """
        result = 0
        [odds, even_I, even_II] = self.sort_2_adic()
        for j in odds:
            result += self.unit(j,2) % 8
            if self.valuation(j,2) % 2 != 0 and kronecker_symbol(self.unit(j,2), 2) == -1:
                result += 4
        for j in even_II[::2]:
            if self.valuation(j,2) % 2 != 0:
                result += 4
        return result % 8

    @cached_method
    def weil_index(self, p):
        """
        Return the local Weil index of this lattice at the prime p.
        
        INPUT:     
            `p` -- a positive prime number
        
        OUTPUT:
            an 8th root of unity, i.e. a power of e**(pi * i / 4)
        
        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L.weil_index(2)
            1
            sage: L.weil_index(3)
            1
        
            sage: L = Lattice(2 * matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L.weil_index(2)
            1
            sage: L.weil_index(3)
            1
        
            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: L.weil_index(2)
            1
            sage: L.weil_index(3)
            I
        
            sage: L = Lattice(2 * matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: L.weil_index(2)
            -1
            sage: L.weil_index(3)
            -I
        
            sage: L = Lattice(3 * matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: L.weil_index(2)
            1
            sage: L.weil_index(3)
            I

            sage: L = Lattice(ZZ, 1, [1])
            sage: L.weil_index(2)
            e^(1/4*I*pi)
        
            sage: L = Lattice(ZZ, 1, [2])
            sage: L.weil_index(2)
            e^(1/4*I*pi)
        
            sage: L = Lattice(ZZ, 1, [3])
            sage: L.weil_index(2)
            e^(7/4*I*pi)
            sage: L.weil_index(3)
            I
        
            sage: L = Lattice(ZZ, 1, [4])
            sage: L.weil_index(2)
            e^(1/4*I*pi)
        
            sage: L = Lattice(ZZ, 1, [5])
            sage: L.weil_index(2)
            e^(1/4*I*pi)
            sage: L.weil_index(5)
            1
        
            sage: L = Lattice(ZZ, 1, [6])
            sage: L.weil_index(2)
            e^(3/4*I*pi)
            sage: L.weil_index(3)
            -I
        
            sage: L = Lattice(ZZ, 1, [7])
            sage: L.weil_index(2)
            e^(7/4*I*pi)
            sage: L.weil_index(7)
            I
        
            sage: L = Lattice(ZZ, 1, [8])
            sage: L.weil_index(2)
            e^(1/4*I*pi)
        
        """
        zeta_8 = exp(pi * I / 4) #sqrt(I)
        if p==2:
            return zeta_8**self.oddity()
        else:
            return zeta_8**-self.p_excess(p)
                
    @cached_method
    def sort_2_adic(self):
        """
        Returns a list containing three lists. 
        The first of these contains the indices of the indices belonging to odd 2-adic blocks in the 2-adic local normal form,
        the second list are indices of even 2-adic blocks of type I and the third list are indeces of even 2-adic blocks of type II.
        
        OUTPUT:
            list
        
        EXAMPLES::

            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L.sort_2_adic()
            [[], [0, 1], []]
        
            sage: L = Lattice(matrix(2 ,2 ,[2, 1, 1, 2]))
            sage: L.sort_2_adic()
            [[], [], [0, 1]]
        
            sage: L = Lattice(matrix(2 ,2 ,[2, 0, 0, 2]))
            sage: L.sort_2_adic()
            [[0, 1], [], []]

            sage: m1 = matrix(2 ,2 ,[2, 0, 0, 2])
            sage: m2 = matrix(2 ,2 ,[2, 1, 1, 2])
            sage: m3 = matrix(2 ,2 ,[0, 1, 1, 0])
            sage: m = m3.block_sum(m1).block_sum(m2)
            sage: L = Lattice(m)
            sage: L.local_normal_form(2)[0]
            [18  0  0  0  0  0]
            [ 0 18  0  0  0  0]
            [ 0  0  0  1  0  0]
            [ 0  0  1  0  0  0]
            [ 0  0  0  0  2  1]
            [ 0  0  0  0  1  2]
            sage: L.sort_2_adic()
            [[0, 1], [2, 3], [4, 5]]
        
        """
        Q_loc = self.local_normal_form(2)[0]
        n = Q_loc.ncols()
        even_I = [j for j in range(n) if Q_loc[j,j] == 0]
        even_II = sorted([j for j in range(n-1) if Q_loc[j,j+1] != 0 and not j in even_I] + [j for j in range(1, n) if Q_loc[j,j-1] != 0 and not j in even_I])
        odds = [j for j in range(n) if not j in (even_I + even_II)]
        return [odds, even_I, even_II]

    def eisenstein_series_by_orbits(self, l, prec=10, verbose=False):
        """
        Return the vector valued Eisenstein series of weight `l` for this lattice and the Weil representation.
        For each orbit (w.r.t. isometries of the discrimanant form) the q-exp is computed only once.
        The idex of each orbit in orbits = self.isometry_orbits() is also the index of the dictionary of
        the q-expansion in the output.

        INPUT:
            `l` -- a half integer, the weight of the Eisenstein series

            `prec` -- the precision to which the Eisenstein series will be computed (default: 10)

        OUTPUT:
            a dicionary of dictionaries
        
        EXAMPLES::
      
            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
            sage: L.eisenstein_series(4, prec = 10)
            {(0, 0): {0: 1,
              1: 240,
              2: 2160,
              3: 6720,
              4: 17520,
              5: 30240,
              6: 60480,
              7: 82560,
              8: 140400,
              9: 181680}}
            sage: L.isometry_orbits()
            [[(0, 0)]]
            sage: L.eisenstein_series_by_orbits(4, prec = 10)
            {0: {0: 1,
              1: 240,
              2: 2160,
              3: 6720,
              4: 17520,
              5: 30240,
              6: 60480,
              7: 82560,
              8: 140400,
              9: 181680}}

        ::

            sage: L = Lattice(matrix(2,2,[2,1,1,2]))
            sage: L.eisenstein_series(5, prec = 10)
            {(0, 0): {0: 1,
              1: 246,
              2: 3600,
              3: 19686,
              4: 59286,
              5: 149760,
              6: 295200,
              7: 590892,
              8: 925200,
              9: 1594326},
             (1/3, 1/3): {1/3: 3,
              4/3: 723,
              7/3: 7206,
              10/3: 28080,
              13/3: 85686,
              16/3: 185043,
              19/3: 390966,
              22/3: 658800,
              25/3: 1170003,
              28/3: 1736646},
             (2/3, 2/3): {1/3: 3,
              4/3: 723,
              7/3: 7206,
              10/3: 28080,
              13/3: 85686,
              16/3: 185043,
              19/3: 390966,
              22/3: 658800,
              25/3: 1170003,
              28/3: 1736646}}
            sage: L.isometry_orbits()
            [[(0, 0)], [(2/3, 2/3), (1/3, 1/3)]]
            sage: L.eisenstein_series_by_orbits(5, prec = 10)
            {0: {0: 1,
              1: 246,
              2: 3600,
              3: 19686,
              4: 59286,
              5: 149760,
              6: 295200,
              7: 590892,
              8: 925200,
              9: 1594326},
             1: {1/3: 3,
              4/3: 723,
              7/3: 7206,
              10/3: 28080,
              13/3: 85686,
              16/3: 185043,
              19/3: 390966,
              22/3: 658800,
              25/3: 1170003,
              28/3: 1736646}}
        
        """
        orbits = self.isometry_orbits()
        rep_elements = [orbit[0] for orbit in orbits]
        eis = self.eisenstein_series(l, elements=rep_elements, prec=prec, verbose=verbose)
        result = {n : eis[tuple(rep_elements[n])] for n in range(len(rep_elements))}
        return result        
        
    def eisenstein_series(self, l, elements=None, coefficient=None, allow_weight_2 = True, prec=10, verbose=False):
        """
        Return the vector valued Eisenstein series of weight `l` for this lattice and the Weil representation.
        If `elements` are specified, only the expansion for those elements of the discriminant form is computed.
        If `coefficient`(=n) is specified, only n-th coefficient is computed for the wanted elements (prec is ignored).
        If `elements` and `coefficient` are not specified, the whole expansion is computed up to precision `prec`.

        INPUT:
            `l` -- a half integer, the weight of the Eisenstein series
        
            `elements` -- the elements of the discriminant form for which the coefficients are wanted (default: None)

            `coefficient` -- an integer, the number of the coefficient which is wanted (default: None)

            `prec` -- the precision to which the Eisenstein series will be computed (default: 10)

        OUTPUT:
            a dicionary of dictionaries
        
        EXAMPLES::

            ## Compare with classical Modular Forms
            ## ------------------------------------
            sage: from sage.all import ModularForms

            ## Hyperbolic plane
            ## ----------------        
            sage: L = Lattice(matrix(2 ,2 ,[0, 1, 1, 0]))
        
            sage: L.eisenstein_series(4, prec = 10)
            {(0, 0): {0: 1,
              1: 240,
              2: 2160,
              3: 6720,
              4: 17520,
              5: 30240,
              6: 60480,
              7: 82560,
              8: 140400,
              9: 181680}}
            sage: eis = ModularForms(1,4).eisenstein_series()[0]
            sage: coeffs = eis.coefficients(range(100))
            sage: d = dict((j, coeffs[j] / coeffs[0]) for j in range(100))
            sage: d == L.eisenstein_series(4, prec = 100)[(0,0)]
            True

            sage: L.eisenstein_series(6, prec = 10)
            {(0, 0): {0: 1,
              1: -504,
              2: -16632,
              3: -122976,
              4: -532728,
              5: -1575504,
              6: -4058208,
              7: -8471232,
              8: -17047800,
              9: -29883672}}
            sage: eis = ModularForms(1,6).eisenstein_series()[0]
            sage: coeffs = eis.coefficients(range(100))
            sage: d = dict((j, coeffs[j] / coeffs[0]) for j in range(100))
            sage: d == L.eisenstein_series(6, prec = 100)[(0,0)]
            True

            sage: L.eisenstein_series(8, prec = 10)
            {(0, 0): {0: 1,
              1: 480,
              2: 61920,
              3: 1050240,
              4: 7926240,
              5: 37500480,
              6: 135480960,
              7: 395301120,
              8: 1014559200,
              9: 2296875360}}
            sage: eis = ModularForms(1,8).eisenstein_series()[0]
            sage: coeffs = eis.coefficients(range(100))
            sage: d = dict((j, coeffs[j] / coeffs[0]) for j in range(100))
            sage: d == L.eisenstein_series(8, prec = 100)[(0,0)]
            True

            ## The E8 lattice
            ## --------------
            sage: L = Lattice(matrix(8,8,[2,-1,0,0,0,0,0,0,
            ....: -1,2,-1,0,0,0,0,0,
            ....: 0,-1,2,-1,0,0,0,-1,
            ....: 0,0,-1,2,-1,0,0,0,
            ....: 0,0,0,-1,2,-1,0,0,
            ....: 0,0,0,0,-1,2,-1,0,
            ....: 0,0,0,0,0,-1,2,0,
            ....: 0,0,-1,0,0,0,0,2]))

            sage: L.eisenstein_series(4, prec = 10)
            {(0, 0, 0, 0, 0, 0, 0, 0): {0: 1,
              1: 240,
              2: 2160,
              3: 6720,
              4: 17520,
              5: 30240,
              6: 60480,
              7: 82560,
              8: 140400,
              9: 181680}}
            sage: eis = ModularForms(1,4).eisenstein_series()[0]
            sage: coeffs = eis.coefficients(range(100))
            sage: d = dict((j, coeffs[j] / coeffs[0]) for j in range(100))
            sage: d == L.eisenstein_series(4, prec = 100)[(0,0,0,0,0,0,0,0)]
            True

            sage: L.eisenstein_series(6, prec = 10)
            {(0, 0, 0, 0, 0, 0, 0, 0): {0: 1,
            1: -504,
            2: -16632,
            3: -122976,
            4: -532728,
            5: -1575504,
            6: -4058208,
            7: -8471232,
            8: -17047800,
            9: -29883672}}
            sage: eis = ModularForms(1,6).eisenstein_series()[0]
            sage: coeffs = eis.coefficients(range(100))
            sage: d = dict((j, coeffs[j] / coeffs[0]) for j in range(100))
            sage: d == L.eisenstein_series(6, prec = 100)[(0,0,0,0,0,0,0,0)]
            True

            sage: L.eisenstein_series(8, prec = 10)
            {(0, 0, 0, 0, 0, 0, 0, 0): {0: 1,
              1: 480,
              2: 61920,
              3: 1050240,
              4: 7926240,
              5: 37500480,
              6: 135480960,
              7: 395301120,
              8: 1014559200,
              9: 2296875360}}
            sage: eis = ModularForms(1,8).eisenstein_series()[0]
            sage: coeffs = eis.coefficients(range(100))
            sage: d = dict((j, coeffs[j] / coeffs[0]) for j in range(100))
            sage: d == L.eisenstein_series(8, prec = 100)[(0,0,0,0,0,0,0,0)]
            True

        ::

            ## The following was confirmed by the Siegel-Weil-Formula after adding an E8-lattice
            ## ---------------------------------------------------------------------------------
            sage: L = Lattice(matrix(2,2,[2,1,1,2]))
            sage: L.eisenstein_series(5, prec = 5)
            {(0, 0): {0: 1, 1: 246, 2: 3600, 3: 19686, 4: 59286},
             (1/3, 1/3): {1/3: 3, 4/3: 723, 7/3: 7206, 10/3: 28080, 13/3: 85686},
             (2/3, 2/3): {1/3: 3, 4/3: 723, 7/3: 7206, 10/3: 28080, 13/3: 85686}}

        ::
            ## Checking that computation of parts of the Eisenstein series
            ## do not interfere afterwards and vice versa
            ## -----------------------------------------------------------
            sage: L = Lattice(matrix(2,2,[2,1,1,2]))
            sage: L.eisenstein_series(5, elements=[], prec = 5)
            {}
            sage: L.eisenstein_series(5, prec = 5)
            {(0, 0): {0: 1, 1: 246, 2: 3600, 3: 19686, 4: 59286},
             (1/3, 1/3): {1/3: 3, 4/3: 723, 7/3: 7206, 10/3: 28080, 13/3: 85686},
             (2/3, 2/3): {1/3: 3, 4/3: 723, 7/3: 7206, 10/3: 28080, 13/3: 85686}}
            sage: L.eisenstein_series(5, elements=[], prec = 5)
            {}

            sage: L = Lattice(matrix(2,2,[2,1,1,2]))
            sage: L.eisenstein_series(5, coefficient = 3, prec = 5)
            {(0, 0): {3: 19686}, (1/3, 1/3): {10/3: 28080}, (2/3, 2/3): {10/3: 28080}}
            sage: L.eisenstein_series(5, prec = 5)
            {(0, 0): {0: 1, 1: 246, 2: 3600, 3: 19686, 4: 59286},
             (1/3, 1/3): {1/3: 3, 4/3: 723, 7/3: 7206, 10/3: 28080, 13/3: 85686},
             (2/3, 2/3): {1/3: 3, 4/3: 723, 7/3: 7206, 10/3: 28080, 13/3: 85686}}
            sage: L.eisenstein_series(5, coefficient = 3, prec = 5)
            {(0, 0): {3: 19686}, (1/3, 1/3): {10/3: 28080}, (2/3, 2/3): {10/3: 28080}}

            sage: L.eisenstein_series(5, elements=[elt], coefficient = 3, prec = 5)
            {(1/3, 1/3): {10/3: 28080}}
            sage: L.eisenstein_series(5, prec = 5)
            {(0, 0): {0: 1, 1: 246, 2: 3600, 3: 19686, 4: 59286},
             (1/3, 1/3): {1/3: 3, 4/3: 723, 7/3: 7206, 10/3: 28080, 13/3: 85686},
             (2/3, 2/3): {1/3: 3, 4/3: 723, 7/3: 7206, 10/3: 28080, 13/3: 85686}}
            sage: L.eisenstein_series(5, elements=[elt], coefficient = 3, prec = 5)
            {(1/3, 1/3): {10/3: 28080}}
        
        """
        if coefficient == None:
            coefficients = [Integer(m) for m in range(prec)]
        else:
            coefficients = [Integer(coefficient)]
            prec = coefficient + 1
        
        if self._lattice_data.get('eisenstein_prec') == None:
            self._lattice_data['eisenstein_series'] = {}
            self._lattice_data['eisenstein_prec'] = {}
        if self._lattice_data['eisenstein_prec'].get(l) >= prec:
            result = dict()
            if elements == None:
                elements = self._lattice_data['eisenstein_series'][l].keys()
            for el in [tuple(el) for el in elements]:
                result[el] = dict()
                for q_pow in self._lattice_data['eisenstein_series'][l][el].keys():
                    if floor(q_pow) in coefficients:
                        result[el][q_pow] = self._lattice_data['eisenstein_series'][l][el][q_pow]
            return result
                    
        l = l * Integer(1)
        if l < 2 or (l == 2 and not allow_weight_2) :
            raise NotImplementedError, "l should be > 2. l=" + l.str()
        n = Integer(self.dimension())
        case = n % 2 # If case == 1, we are dealing with the odd case. If case == 0, we are dealing with the odd case.
        kappa = Integer( (-1)**Integer(((n-1)*n)/2) * self.det_squarefree_part() * 2**(case *(1 - 2*self.det_squarefree_part().valuation(2)) ) )
        if verbose:
            print "kappa:", kappa

        if case:
            #Checking conditon (2.10) in [KY]
            if l.denominator() != 2 or (((Integer(2 * l) - kappa.sign()) % 4) != 0):
                raise NotImplementedError, "l=" + l.str() + ", kappa=" + kappa.str()
        else:
            #Checking conditon (2.10) in [KY]
            if not l.is_integer() or ((-1)**l != kappa.sign()):
                raise NotImplementedError, "l=" + l.str() + ", kappa=" + kappa.str()

        S = self.det().prime_divisors()
            
        def b(p, m, s, D):
            d = (kappa * m).squarefree_part()
            #d = Integer(d.numerator()*d.denominator()) # This should not be necessary
            if (d-1) % 4 != 0:
                d *= 4
            c = (4 * kappa * m / d).sqrt()
            vp = kronecker_symbol(d,p)
            X = p**(-s)
            k = c.valuation(p) 
            if k < 0:
                return 1
            elif D % p != 0:
                return (1 - vp*X + p**k*vp*X**(1+2*k) - p**(k+1)*X**(2*k+2)) / (1 - p*X**2)
            else:
                return ((1 - vp*X)*(1 - p**2*X**2) - p**(k+1)*vp*X**(1+2*k) + p**(k+2)*X**(2*k+2) + vp*p**(k+1)*X**(2*k+3) - p**(2*k+2)*X**(2*k+4)) / (1 - p*X**2)
                
        fac = 2**l * pi**l * exp(-l / 2 * pi * I) / gamma__exact(l)
        if verbose:
            print "(-2 * pi * I)**l:",(-2 * pi * I)**l, "\ngamma__exact(l):", gamma__exact(l), "\nfac:", fac

        result = {}
        
        #The odd case:
        if case:
            fac /= zeta__exact(Integer(2*l - 1))
            for p in S:
                if verbose:
                    print "p:", p
                fac *= self.weil_index(p) * p**(-self.det().valuation(p)/Integer(2)) / (1 - p**Integer(1 - 2*l))
            fac = {0 : fac}
            #L_values = dict()
            if verbose:
                print "odd case"
                print fac
            if elements != None:
                iterator = elements
            else:
                iterator = self.discriminant_form_iterator()
            for lattice_element in iterator:
                if verbose:
                    print "lattice_element:", lattice_element
                offset = lattice_element.Q() - floor(lattice_element.Q())
                result[tuple(lattice_element)] = {}
                for m in [offset + j for j in coefficients]:
                    if verbose:
                        print "m:", m
                    if m == 0:
                        if lattice_element == 0:
                            result[tuple(lattice_element)][m] = 1
                        #else:
                        #    result[tuple(lattice_element)][m] = 0
                    else:
                        if not m in fac.keys():
                            d = (kappa * m).squarefree_part()                            
                            #d = Integer(d.numerator()*d.denominator()) # This should not be necessary
                            if (d-1) % 4 != 0:
                                d *= 4
                            #if not d in L_values.keys():
                            #    L_values[d] = quadratic_L_function__exact(floor(l), d)
                            #    for p in S:
                            #        L_values[d] *= (1 - kronecker_symbol(d,p) * p**(- floor(l)))
                            if verbose:
                                print "Dirichlet Character: d=", d
                            L_value = quadratic_L_function__exact(Integer(floor(l)), Integer(d))
                            for p in S:
                                L_value *= (1 - kronecker_symbol(d,p) * p**(- floor(l)))
                            if verbose:
                                print "m**(l-1):", m**(l-1)
                            #fac[m] = m**(l-1) * L_values[d]
                            fac[m] = m**(l-1) * L_value
                            #res = fac * m**(l-1) * L_values[d]
                            if verbose:
                                print "m**(l-1) * L_value:", fac[m]
                                factors = dict()
                                factors[0] = [fac, m**(l-1), quadratic_L_function__exact(floor(l), d), 1 / zeta__exact(Integer(2*l - 1))]
                                #print "1:", res
                                #res /= (1 - p**Integer(1 - 2*l)) / (1 - kronecker_symbol(d,p) * p**(- floor(l)))
                            #    if verbose:
                            #        factors[p]=[1 / (1 - p**Integer(1 - 2*l))]
                            #        factors[p].append((1 - kronecker_symbol(d,p) * p**(- floor(l))))
                            #        print "2:", p, res
                            #    res *= lattice_element.W(p, m, Integer(l - n/Integer(2))) * self.weil_index(p) * p**(-self.det().valuation(p)/2)
                            #    if verbose:
                            #        factors[p].append(lattice_element.W(p, m, Integer(l - n/Integer(2))))
                            #        factors[p].append(self.weil_index(p))
                            #        factors[p].append(p**(-self.det().valuation(p)/2))
                            #        print "3:", p, res
                            for p in (2*m.numerator()).prime_divisors():
                                if not p in S:
                                    fac[m] *= b(p, m, floor(l) , 1)
                                    #res *= b(p, m, floor(l) , 1)
                                    if verbose:
                                        factors[p]=(b(p, m, floor(l), 1))
                                        print "p, b(p,m,...)", p, factors[p]
                                    #    print "4:", p, res
                        res = fac[0]*fac[m]
                        if verbose:
                            print "Current result:", res
                        for p in S:
                            res *= lattice_element.W(p, m, Integer(l - n/Integer(2)))
                            if verbose:
                                print "res*W_" + str(p) + ":", res
                        res = res.simplify()
                        res = sign(RR(res)) * sqrt(QQ(res**2))
                        res = QQ(res)
                        if res != 0:
                            result[tuple(lattice_element)][m] = res #(res, factors) #QQ(res)
                        if verbose:
                            print "factors:", factors

        #The even case:
        else:
            if verbose:
                print "even case"
            d = kappa.squarefree_part()
            #d = Integer(d.numerator()*d.denominator()) # This should not be necessary
            if (d-1) % 4 != 0:
                d *= 4
            #print fac
            #print l, d
            #print quadratic_L_function__exact(Integer(l),Integer(d))
            fac /= quadratic_L_function__exact(Integer(l),Integer(d))
            for p in S:
                fac /= (1 - kronecker_symbol(d,p) * p**(-l))
            if verbose:
                print "kappa:", kappa
                print "d:    ", d
                print "fac:  ", fac
            if elements != None:
                iterator = elements
            else:
                iterator = self.discriminant_form_iterator()
            for lattice_element in iterator:
                if verbose:
                    print "lattice_element:", lattice_element
                offset = lattice_element.Q() - floor(lattice_element.Q())
                result[tuple(lattice_element)] = {} #{-1 : offset}
                for m in [offset + j for j in coefficients]:
                    if m == 0:
                        if lattice_element == 0:
                            result[tuple(lattice_element)][m] = 1
                        #else:
                        #    result[tuple(lattice_element)][m] = 0
                    else:
                        res = fac * m**(l-1)
                        for p in S:
                            res *= lattice_element.W(p, m, Integer(l - n/2)) * self.weil_index(p) * p**(-self.det().valuation(p)/2)
                        for p in m.numerator().prime_divisors():
                            if not p in S:
                                res *= sum([(hilbert_symbol(p, kappa, p) * p**(1-l))**Integer(r) for r in range(m.valuation(p)+1)])
                        #for p in m.denominator().prime_divisors():
                        #    if not p in S:
                        #        res /= sum([(hilbert_symbol(p, kappa, p) * p**(1-l))**Integer(r) for r in range(m.valuation(p)+1)])
                        res = res.simplify()
                        res = sign(RR(res)) * sqrt(QQ(res**2))
                        res = QQ(res)
                        if res != 0:
                            result[tuple(lattice_element)][m] = res #(res, RR(res))#QQ(res)
        #print ds
        if elements == None and coefficient == None:
            self._lattice_data['eisenstein_prec'][l] = prec
            self._lattice_data['eisenstein_series'][l] = result                            
        return result

                    
    def theta_series(self, prec=10, verbose=False):
        """
        Return the vector valued theta series of this lattice (if this lattice is positive definite)
        up to the given precision `prec`.

        INPUT:
            `prec` -- the precision to which the theta series will be computed (default: 10)

        OUTPUT:
            a dicionary of dictionaries
        
        EXAMPLES::

            ## The E8 lattice
            ## --------------
            sage: L = Lattice(matrix(8,8,[2,-1,0,0,0,0,0,0,
            ....: -1,2,-1,0,0,0,0,0,
            ....: 0,-1,2,-1,0,0,0,-1,
            ....: 0,0,-1,2,-1,0,0,0,
            ....: 0,0,0,-1,2,-1,0,0,
            ....: 0,0,0,0,-1,2,-1,0,
            ....: 0,0,0,0,0,-1,2,0,
            ....: 0,0,-1,0,0,0,0,2]))
            sage: L.theta_series(prec = 5)
            {(0, 0, 0, 0, 0, 0, 0, 0): {0: 1, 1: 240, 2: 2160, 3: 6720, 4: 17520}}
        
        """
        if self._lattice_data.get('theta_prec', -1) >= prec:
            result = dict()
            for el in self._lattice_data['theta_series'].keys():
                result[el] = dict()
                for q_pow in self._lattice_data['theta_series'][el].keys():
                    if q_pow < prec:
                        result[el][q_pow] = self._lattice_data['theta_series'][el][q_pow]
            return result
        gram_mat = self.Q.matrix()
        if not gram_mat.is_positive_definite():
            raise TypeError, "The Gram matrix must be positive definite."
        result = dict()
        for dual_lattice_element in self.discriminant_form_iterator():
            result[tuple(dual_lattice_element)] = dict()
        n = self.dimension()
        N = self.level()
        gram_inv = gram_mat.inverse()
        gram_inv_scaled = N * gram_inv
        QF = QuadraticForm(ZZ, gram_inv_scaled)
        #print "computing vectors"
        vecs_by_len = QF.short_vector_list_up_to_length(len_bound = prec * N)
        #print "done"
        for l in range(prec * N):
            lN = Integer(l)/Integer(N)
            for v in vecs_by_len[l]:
                dual_lattice_element = tuple(matrix(1,n,list(v)) * gram_inv)[0]
                d_tuple = tuple([j - floor(j) for j in dual_lattice_element])
                if lN < prec:
                    if lN in result[d_tuple].keys():
                        result[d_tuple][lN] += 1
                    else:
                        result[d_tuple][lN] = 1
        self._lattice_data['theta_prec'] = prec
        self._lattice_data['theta_series'] = result
        return result
    
    def isometry_orbits(self, verbose = False):
        """
        Return the vector valued theta series of this lattice (if this lattice is positive definite)
        up to the given precision `prec`.

        INPUT:
            `prec` -- the precision to which the theta series will be computed (default: 10)

        OUTPUT:
            a dicionary of dictionaries
        
        EXAMPLES::

            ## The hyperbolic plane
            ## --------------
            sage: L = Lattice(matrix(2,2,[0,1,1,0]))
            sage: L.isometry_orbits()
            [[(0, 0)]]

            ## The E8 lattice
            ## --------------
            sage: L = Lattice(matrix(8,8,[2,-1,0,0,0,0,0,0,
            ....: -1,2,-1,0,0,0,0,0,
            ....: 0,-1,2,-1,0,0,0,-1,
            ....: 0,0,-1,2,-1,0,0,0,
            ....: 0,0,0,-1,2,-1,0,0,
            ....: 0,0,0,0,-1,2,-1,0,
            ....: 0,0,0,0,0,-1,2,0,
            ....: 0,0,-1,0,0,0,0,2]))
            sage: L.isometry_orbits()
            [[(0, 0, 0, 0, 0, 0, 0, 0)]]

            sage: L = Lattice(matrix(2,2,[2,1,1,2]))
            sage: sorted([sorted(orb) for orb in L.isometry_orbits()])
            [[(0, 0)], [(1/3, 1/3), (2/3, 2/3)]]

            sage: L = Lattice(matrix(1,1,[2]))
            sage: sorted([sorted(orb) for orb in L.isometry_orbits()])
            [[(0)], [(1/2)]]

            sage: L = Lattice(matrix(1,1,[4]))
            sage: sorted([sorted(orb) for orb in L.isometry_orbits()])
            [[(0)], [(1/4), (3/4)], [(1/2)]]

            sage: m = matrix(2,2,[2,1,1,2])
            sage: L = Lattice(m.block_sum(m))
            sage: sorted([sorted(orb) for orb in L.isometry_orbits()])
            [[(0, 0, 0, 0)],
             [(0, 0, 1/3, 1/3), (0, 0, 2/3, 2/3), (1/3, 1/3, 0, 0), (2/3, 2/3, 0, 0)],
             [(1/3, 1/3, 1/3, 1/3),
              (1/3, 1/3, 2/3, 2/3),
              (2/3, 2/3, 1/3, 1/3),
              (2/3, 2/3, 2/3, 2/3)]]
        
        """
        orbits = []
        if self._lattice_data.get('isometry_orbits') != None:
            for orbit in self._get_lattice_data('isometry_orbits'):
                orbits.append([LatticeSpaceElementOverQQ(self, el) for el in orbit])
            return orbits
        els = []
        for el in self.discriminant_form_iterator():
            if el in els:
                continue
            orbit = el.isometry_orbit()
            orbits.append(orbit)
            els.extend(list(orbit))
        orbit_tuples = []
        for orbit in orbits:
            orbit_tuples.append([tuple(el) for el in orbit])
        self._set_lattice_data('isometry_orbits', orbit_tuples)
        return orbits

    def theta_series_symmetrized(self, prec = 10, short = False, verbose = False):
        """
        Return the symmetrized vector valued theta series of this lattice (if this lattice is positive definite)
        up to the given precision `prec`.

        INPUT:
            `prec` -- the precision to which the theta series will be computed (default: 10)

        OUTPUT:
            a dicionary of dictionaries
        
        EXAMPLES::

            ## The E8 lattice
            ## --------------
            sage: L = Lattice(matrix(8,8,[2,-1,0,0,0,0,0,0,
            ....: -1,2,-1,0,0,0,0,0,
            ....: 0,-1,2,-1,0,0,0,-1,
            ....: 0,0,-1,2,-1,0,0,0,
            ....: 0,0,0,-1,2,-1,0,0,
            ....: 0,0,0,0,-1,2,-1,0,
            ....: 0,0,0,0,0,-1,2,0,
            ....: 0,0,-1,0,0,0,0,2]))
            sage: L.theta_series_symmetrized(prec = 5)
            {((0, 0, 0, 0, 0, 0, 0, 0),): {0: 1, 1: 240, 2: 2160, 3: 6720, 4: 17520}}

        ::
        
            ## Siegel-Weil formula with class number 1
            ## ---------------------------------------
            sage: m = matrix(2,2,[2,1,1,2])
            sage: L = Lattice(diagonal_matrix([2]).block_sum(m).block_sum(m))
            sage: L.theta_series_symmetrized(prec = 3)
            {(0, 0, 0, 0, 0): {0: 1, 1: 14, 2: 60},
             (0, 0, 0, 1/3, 1/3): {1/3: 3, 4/3: 27, 7/3: 66},
             (0, 0, 0, 2/3, 2/3): {1/3: 3, 4/3: 27, 7/3: 66},
             (0, 1/3, 1/3, 0, 0): {1/3: 3, 4/3: 27, 7/3: 66},
             (0, 1/3, 1/3, 1/3, 1/3): {2/3: 9, 5/3: 36, 8/3: 81},
             (0, 1/3, 1/3, 2/3, 2/3): {2/3: 9, 5/3: 36, 8/3: 81},
             (0, 2/3, 2/3, 0, 0): {1/3: 3, 4/3: 27, 7/3: 66},
             (0, 2/3, 2/3, 1/3, 1/3): {2/3: 9, 5/3: 36, 8/3: 81},
             (0, 2/3, 2/3, 2/3, 2/3): {2/3: 9, 5/3: 36, 8/3: 81},
             (1/2, 0, 0, 0, 0): {1/4: 2, 5/4: 24, 9/4: 74},
             (1/2, 0, 0, 1/3, 1/3): {7/12: 6, 19/12: 42, 31/12: 54},
             (1/2, 0, 0, 2/3, 2/3): {7/12: 6, 19/12: 42, 31/12: 54},
             (1/2, 1/3, 1/3, 0, 0): {7/12: 6, 19/12: 42, 31/12: 54},
             (1/2, 1/3, 1/3, 1/3, 1/3): {11/12: 18, 23/12: 36, 35/12: 108},
             (1/2, 1/3, 1/3, 2/3, 2/3): {11/12: 18, 23/12: 36, 35/12: 108},
             (1/2, 2/3, 2/3, 0, 0): {7/12: 6, 19/12: 42, 31/12: 54},
             (1/2, 2/3, 2/3, 1/3, 1/3): {11/12: 18, 23/12: 36, 35/12: 108},
             (1/2, 2/3, 2/3, 2/3, 2/3): {11/12: 18, 23/12: 36, 35/12: 108}}
            sage: L.eisenstein_series(5 / 2, prec = 3) == L.theta_series_symmetrized(prec = 3)
            True

            sage: L = Lattice(m.block_sum(m).block_sum(m))
            sage: L.theta_series_symmetrized(prec = 3)
            {(0, 0, 0, 0, 0, 0): {0: 1, 1: 18, 2: 108},
             (0, 0, 0, 0, 1/3, 1/3): {1/3: 3, 4/3: 39, 7/3: 150},
             (0, 0, 0, 0, 2/3, 2/3): {1/3: 3, 4/3: 39, 7/3: 150},
             (0, 0, 1/3, 1/3, 0, 0): {1/3: 3, 4/3: 39, 7/3: 150},
             (0, 0, 1/3, 1/3, 1/3, 1/3): {2/3: 9, 5/3: 72, 8/3: 153},
             (0, 0, 1/3, 1/3, 2/3, 2/3): {2/3: 9, 5/3: 72, 8/3: 153},
             (0, 0, 2/3, 2/3, 0, 0): {1/3: 3, 4/3: 39, 7/3: 150},
             (0, 0, 2/3, 2/3, 1/3, 1/3): {2/3: 9, 5/3: 72, 8/3: 153},
             (0, 0, 2/3, 2/3, 2/3, 2/3): {2/3: 9, 5/3: 72, 8/3: 153},
             (1/3, 1/3, 0, 0, 0, 0): {1/3: 3, 4/3: 39, 7/3: 150},
             (1/3, 1/3, 0, 0, 1/3, 1/3): {2/3: 9, 5/3: 72, 8/3: 153},
             (1/3, 1/3, 0, 0, 2/3, 2/3): {2/3: 9, 5/3: 72, 8/3: 153},
             (1/3, 1/3, 1/3, 1/3, 0, 0): {2/3: 9, 5/3: 72, 8/3: 153},
             (1/3, 1/3, 1/3, 1/3, 1/3, 1/3): {1: 27, 2: 81},
             (1/3, 1/3, 1/3, 1/3, 2/3, 2/3): {1: 27, 2: 81},
             (1/3, 1/3, 2/3, 2/3, 0, 0): {2/3: 9, 5/3: 72, 8/3: 153},
             (1/3, 1/3, 2/3, 2/3, 1/3, 1/3): {1: 27, 2: 81},
             (1/3, 1/3, 2/3, 2/3, 2/3, 2/3): {1: 27, 2: 81},
             (2/3, 2/3, 0, 0, 0, 0): {1/3: 3, 4/3: 39, 7/3: 150},
             (2/3, 2/3, 0, 0, 1/3, 1/3): {2/3: 9, 5/3: 72, 8/3: 153},
             (2/3, 2/3, 0, 0, 2/3, 2/3): {2/3: 9, 5/3: 72, 8/3: 153},
             (2/3, 2/3, 1/3, 1/3, 0, 0): {2/3: 9, 5/3: 72, 8/3: 153},
             (2/3, 2/3, 1/3, 1/3, 1/3, 1/3): {1: 27, 2: 81},
             (2/3, 2/3, 1/3, 1/3, 2/3, 2/3): {1: 27, 2: 81},
             (2/3, 2/3, 2/3, 2/3, 0, 0): {2/3: 9, 5/3: 72, 8/3: 153},
             (2/3, 2/3, 2/3, 2/3, 1/3, 1/3): {1: 27, 2: 81},
             (2/3, 2/3, 2/3, 2/3, 2/3, 2/3): {1: 27, 2: 81}}
            sage: L.eisenstein_series(3, prec = 3) == L.theta_series_symmetrized(prec = 3)
            True
        
        """
        def short_to_long(result):
            if result.keys()[0][0] in QQ:
                return result
            long_result = dict()
            for orbit in result.keys():
                for elt in orbit:
                    long_result[elt] = result[orbit]
            return long_result
            
        def long_to_short(result):
            orbits = self.isometry_orbits()
            if not(result.keys()[0][0] in QQ):
                return result
            short_result = dict()
            for orbit in orbits:
                orb_tuple = (tuple(elt) for elt in orbit)
                short_result[orb_tuple] = result[orb_tuple[0]]
        
        if self._lattice_data.get('symmetrized_theta_prec', -1) >= prec:
            #print self._symmetrized_theta_prec, prec, self._symmetrized_theta_prec >= prec
            result = dict()
            for el in self._lattice_data['symmetrized_theta_series'].keys():
                result[el] = dict()
                for q_pow in self._lattice_data['symmetrized_theta_series'][el].keys():
                    if q_pow < prec:
                        result[el][q_pow] = self._lattice_data['symmetrized_theta_series'][el][q_pow]
            if short:
                return long_to_short(result)
            else:
                return short_to_long(result)

        th = self.theta_series(prec = prec)
        n = len(self.discriminant_form_isometries())

        def dict_add(d1, d2):
            return {k : d1.get(k, 0) + d2.get(k, 0) for k in uniq(d1.keys() + d2.keys())}

        def dict_mul(d, scalar):
            return {k : scalar * d[k] for k in d.keys()}

        result = dict()

        orbits = self.isometry_orbits()
        for orbit in orbits:
            d = dict()
            orb_tuple = tuple([tuple(elt) for elt in orbit])
            for elt in orbit:
                d = dict_add(d, th[tuple(elt)])
            result[orb_tuple] = dict_mul(d, Integer(1) / len(orbit))

        self._set_lattice_data('symmetrized_theta_prec', prec)
        self._set_lattice_data('symmetrized_theta_series', result)
            
        if short:
            return result
        else:
            return short_to_long(result)
            
        
class LatticeSpaceElementOverQQ(FreeModuleElement_generic_dense):
    r"""
    The ``LatticeSpaceElementOverQQ`` class represents elements in `\Q^n` which is endowed with a quadratic form in n variables with
    coefficients in the ring `\Z`. The main use of this class is representing elements in the dual lattice of the parent lattice. 

    INPUT:

    The constructor may be called in any of the following ways.

    #. ``LatticeSpaceElementOverQQ(L, entries)``, where

       - ``L`` -- a lattice (class `Lattice`)
       - ``entries`` -- a tuple or list of `L.dim()` coefficients in QQ
    
    OUTPUT:

    an element of the parent lattice tensored with QQ, represented by QQ^n

    EXAMPLES::

        sage: L = Lattice(matrix(2,2,[2,1,1,2]))
        sage: el = LatticeSpaceElementOverQQ(L, (1,1))
        sage: el
        (1, 1)
        sage: el.Q()
        3

        sage: L = Lattice(matrix(2,2,[2,1,1,2]))
        sage: el = LatticeSpaceElementOverQQ(L, [1,1])
        sage: el
        (1, 1)
        sage: el.Q()
        3

    """
    def __init__(self, parent, entries):
        if not(isinstance(parent, Lattice)):
            raise TypeError, "The parent must be a Lattice."
        #FreeModuleElement_generic_dense.__init__(self, parent.change_ring(parent.base_field()), entries)
        FreeModuleElement_generic_dense.__init__(self, parent.change_ring(QQ), entries)
        self._Q = parent.Q_field(self)
        self._int_parent = parent

    def __add__(self, other):
        """
        Adding elements.

        EXAMPLES::

            sage: L = Lattice(matrix(2,2,[2,1,1,2]))
            sage: el0 = LatticeSpaceElementOverQQ(L, (1,2))
            sage: el1 = LatticeSpaceElementOverQQ(L, (1/2,1/3))
            sage: el0 + el1
            (3/2, 7/3)
            sage: (el0 + el1).Q()
            403/36

        """
        #print "__add__(", self, other, ")"
        #if other == 0:
        #    return self
        if other._int_parent == self._int_parent:
            return LatticeSpaceElementOverQQ(self._int_parent, map(lambda x,y : x+y, tuple(self), tuple(other)))
        else:
            raise TypeError, "These elements don't live in the same quadratic space"
            
## These seem to be no use!
## ------------------------            
#    def __radd__(self, other):
#        print "__radd__(", self, other, ")"
#        if other == 0:
#            return self
#        else:
#            return self.__add__(other)
#
#    def __ladd__(self, other):
#        print "__ladd__(", self, other, ")"
#        if other == 0:
#            return self
#        else:
#            return self.__add__(other)

    def _sub_(self, other):
        """
        Subtracting elements.

        EXAMPLES::

            sage: L = Lattice(matrix(2,2,[2,1,1,2]))
            sage: el0 = LatticeSpaceElementOverQQ(L, (1,2))
            sage: el1 = LatticeSpaceElementOverQQ(L, (1/2,1/3))
            sage: el0 - el1
            (1/2, 5/3)
            sage: (el0 - el1).Q()
            139/36
           
        """
        #print "_sub_(", self, other, ")"
        #if other == 0:
        #    return self
        if other._int_parent == self._int_parent:
            return LatticeSpaceElementOverQQ(self._int_parent, map(lambda x,y : x-y, tuple(self), tuple(other)))
        else:
            raise TypeError, "These elements don't live in the same quadratic space"

    def _neg_(self):
        """
        Negating elements.

        EXAMPLES::

            sage: L = Lattice(matrix(2,2,[2,1,1,2]))
            sage: el0 = LatticeSpaceElementOverQQ(L, (1,2))
            sage: - el0
            (-1, -2)
            sage: (- el0).Q()
            7

        """
        #print "_neg_(", self, ")"
        return LatticeSpaceElementOverQQ(self._int_parent, map(lambda x : -x ,tuple(self)))
        
    def _lmul_(self, other):
        """
        Scaling elements.

        EXAMPLES::

            sage: L = Lattice(matrix(2,2,[2,1,1,2]))
            sage: el0 = LatticeSpaceElementOverQQ(L, (1,2))
            sage: el0 * 2
            (2, 4)
            sage: (el0 * 2).Q()
            28
           
        """
        if other == 1:
            return self
        try:
            factor = QQ(other)
            return LatticeSpaceElementOverQQ(self._int_parent, map(lambda x : x * factor ,tuple(self)))
        except TypeError as e:
            raise TypeError, e

    def _rmul_(self, other):
        """
        Scaling elements.

        EXAMPLES::

            sage: L = Lattice(matrix(2,2,[2,1,1,2]))
            sage: el0 = LatticeSpaceElementOverQQ(L, (1,2))
            sage: 2 * el0
            (2, 4)
            sage: (2 * el0).Q()
            28
           
        """
        return self._lmul_(other)

    def Q(self):
        """
        Return the quadratic form of the parent evaluated at self.

        EXAMPLES::

            sage: L = Lattice(matrix(2,2,[2,1,1,2]))
            sage: el0 = LatticeSpaceElementOverQQ(L, (1,2))
            sage: el0.Q()
            7
            sage: el1 = LatticeSpaceElementOverQQ(L, (1/2,1/3))
            sage: el1.Q()
            19/36
           
        """
        return self._Q
        
    def inner_product(self, other):
        """
        Evaluate the bilinear form `B` associated with the quadratic form of the parent
        at self and other (note B(x,x) = 2Q(x) and B(x,y) = Q(x+y)-Q(x)-Q(y)).

        EXAMPLES::

            sage: L = Lattice(matrix(2,2,[2,1,1,2]))
            sage: el0 = LatticeSpaceElementOverQQ(L, (1,2))
            sage: el1 = LatticeSpaceElementOverQQ(L, (1/2,1/3))
            sage: el0.inner_product(el1)
            11/3
           
        """
        return (self + other).Q() - self.Q() - other.Q()

    def integral_parent(self):
        """
        Return the Lattice belonging to this `LatticeSpaceElementOverQQ`

        EXAMPLES::

            sage: L = Lattice(matrix(2,2,[2,1,1,2]))
            sage: el0 = LatticeSpaceElementOverQQ(L, (1,2))
            sage: el0.integral_parent() == L
            True
           
        """
        return self._int_parent

    def isometry_orbit(self):
        """
        Return the isometry orbit of self viewed as an element in the discriminant form of the parent lattice.

        EXAMPLES::

            sage: L = Lattice(matrix(2,2,[2,1,1,2]))
            sage: el0 = LatticeSpaceElementOverQQ(L, (1,2))
            sage: sorted(el0.isometry_orbit())
            [(0, 0)]
        
            sage: el1 = LatticeSpaceElementOverQQ(L, (1/3,1/3))
            sage: sorted(el1.isometry_orbit())
            [(1/3, 1/3), (2/3, 2/3)]

            ## If the coordinates do not represent an element in the discriminant form:
            sage: el2 = LatticeSpaceElementOverQQ(L, (1/2,1/3))
            sage: sorted(el2.isometry_orbit())
            Traceback (most recent call last):
            ...
            TypeError: no conversion of this rational to integer
           
        """
        L = self.integral_parent()
        el_fin_ab_grp = L._vector_pres_to_fin_ab_grp_pres(self)
        orbit = []
        for iso in L.discriminant_form_isometries():
            el_image = L._fin_ab_grp_pres_to_vector_pres(iso(el_fin_ab_grp))
            if not el_image in orbit:
                orbit.append(el_image)
        return orbit

    #def muliplicity(self, p, x=None):
    #    pass

    #def reduced_norm(self, p, x=None):
    #    pass
        
    def _get_local_normal_form(self, p):
        """
        Calls the local_normal_form method of the parent lattice.

        INPUT:
            `p` -- a positive prime number

        OUTPUT:
            a quadratic form over ZZ, the corrsponding change of basis (a matrizes over QQ or Zp(2, prec)).

        EXAMPLES::

            sage: L = Lattice(ZZ, 2, [10,4,1])
            sage: el = LatticeSpaceElementOverQQ(L, (1,2))
            sage: el._get_local_normal_form(2) == L.local_normal_form(2)
            True
            
        """
        return self.integral_parent().local_normal_form(p)

    @cached_method
    def _mu_p(self, p):
        """
        Uses the change of basis computed by the local_normal_form method of the parent lattice
        to give the coordinates of self corresponding to the normalized local form of the parent lattice
        for the prime `p`.

        INPUT:
            `p` -- a positive prime number

        OUTPUT:
            a vector over the rationals

        EXAMPLES::

            sage: L = Lattice(matrix(2,2,[2,1,1,2]))
            sage: L.local_normal_form(3)
            (
            [2 0]  [ 1 -1]  [  1 1/2]
            [0 6], [ 0  2], [  0 1/2]
            )
            sage: el = LatticeSpaceElementOverQQ(L, (1/3,1/3))
            sage: el._mu_p(3)
            (1/2, 1/6)
            sage: el._mu_p(3) * L.local_normal_form(3)[0] * el._mu_p(3) == 2 * el.Q()
            True
            sage: el = LatticeSpaceElementOverQQ(L, (2/3,2/3))
            sage: el._mu_p(3)
            (1, 1/3)
            sage: el._mu_p(3) * L.local_normal_form(3)[0] * el._mu_p(3) == 2 * el.Q()
            True
            
        """
        return self._get_local_normal_form(p)[2] * self

    def _mu_p_i(self, p, i):
        """
        Uses the change of basis computed by the local_normal_form method of the parent lattice
        to give the `i`-th coordinate of self corresponding to the normalized local form of the parent lattice
        for the prime `p`.

        INPUT:
            `p` -- a positive prime number

            `i` -- an integer in range(0,n) where n is the dimenstion of the parent lattice

        OUTPUT:
            a rational

        EXAMPLES::

            sage: L = Lattice(matrix(2,2,[2,1,1,2]))
            sage: L.local_normal_form(3)
            (
            [2 0]  [ 1 -1]  [  1 1/2]
            [0 6], [ 0  2], [  0 1/2]
            )
            sage: el = LatticeSpaceElementOverQQ(L, (1/3,1/3))
            sage: el._mu_p(3)
            (1/2, 1/6)
            sage: el._mu_p_i(3,0)
            1/2
            sage: el._mu_p_i(3,1)
            1/6
            sage: el = LatticeSpaceElementOverQQ(L, (2/3,2/3))
            sage: el._mu_p(3)
            (1, 1/3)
            sage: el._mu_p_i(3,0)
            1
            sage: el._mu_p_i(3,1)
            1/3
            
        """
        return self._mu_p(p)[i]

        
    @cached_method
    def H(self, p):
        """
        An invariant from [Kudla, Yang - Eisenstein Series for SL(2)].
        Used in the computation of Eisenstein series for the parent lattice and the Weil representation.
        If p != 2, returns the list `H` of coordinates that are p-adic integers.
        If p == 2, returns a ditcionary with keys 'H', 'M' and 'N' pointing to the corresponding lists
        for odd, type I and type II components.
        These lists are computed for the coordinates of self corresponding to the normalized local
        form for the prime `p`.

        INPUT:
            `p` -- a positive prime number

        OUTPUT:
            a list or a dictionary containing three lists.

        EXAMPLES::

            sage: m = matrix(1,1,[2])
            sage: m = m.block_sum(2 * matrix(2,2,[0,1,1,0]))
            sage: m = m.block_sum(2 * matrix(2,2,[2,1,1,2]))
            sage: L = Lattice(m)
        
            sage: el = LatticeSpaceElementOverQQ(L, (0, 0, 0, 0, 0))
            sage: el.H(2)
            {'H': [0], 'M': [1], 'N': [3]}

            sage: el = LatticeSpaceElementOverQQ(L, (0, 1/2, 0, 1/2, 0))
            sage: el.H(2)
            {'H': [0], 'M': [], 'N': []}

            sage: el = LatticeSpaceElementOverQQ(L, (1/2, 0, 0, 1/2, 0))
            sage: el.H(2)
            {'H': [], 'M': [1], 'N': []}

            sage: el = LatticeSpaceElementOverQQ(L, (1/2, 1/2, 0, 0, 0))
            sage: el.H(2)
            {'H': [], 'M': [], 'N': [3]}

            sage: el = LatticeSpaceElementOverQQ(L, (0, 0, 0, 0, 0))
            sage: el.H(3)
            [0, 1, 2, 3, 4]

            sage: el = LatticeSpaceElementOverQQ(L, (0, 0, 0, 1/3, 1/3))
            sage: el.H(3)
            [0, 1, 2, 3]
        
        """
        if p==2:
            [odds, even_I, even_II] = self.integral_parent().sort_2_adic()
            Hs = [j for j in odds if self._mu_p_i(p, j).valuation(p) >= 0]
            Ms = [j for j in even_I[0::2] if self._mu_p_i(p, j).valuation(p) >= 0 and self._mu_p_i(p, j+1).valuation(p) >= 0]
            Ns = [j for j in even_II[0::2] if self._mu_p_i(p, j).valuation(p) >= 0 and self._mu_p_i(p, j+1).valuation(p) >= 0]
            return {'H':Hs, 'M':Ms, 'N':Ns}
        else:
            return [i for i in range(len(self)) if self._mu_p_i(p, i).valuation(p) >= 0]
    
    def L(self, k, p):
        """
        An invariant from [Kudla, Yang - Eisenstein Series for SL(2)].
        Used in the computation of Eisenstein series for the parent lattice and the Weil representation.
        This list is computed for the coordinates of self corresponding to the normalized local
        form for the prime `p`.

        INPUT:
            `k` -- an integer
        
            `p` -- a positive prime number

        OUTPUT:
            a list.

        EXAMPLES::

            sage: m = diagonal_matrix([2, 4, 8])
            sage: m = m.block_sum(2 * matrix(2,2,[0,1,1,0]))
            sage: m = m.block_sum(4 * matrix(2,2,[2,1,1,2]))
            sage: L = Lattice(m)

            sage: el = LatticeSpaceElementOverQQ(L, (0, 0, 0, 0, 0, 0, 0))
            sage: el.L(1, 2)
            []
            sage: el.L(2, 2)
            [0]
            sage: el.L(3, 2)
            [1]
            sage: el.L(4, 2)
            [0, 2]
            sage: el.L(5, 2)
            [1]
            sage: el.L(6, 2)
            [0, 2]
            sage: el.L(1, 3)
            [0, 1, 2, 3, 4, 5]
            sage: el.L(2, 3)
            [6]
            sage: el.L(3, 3)
            [0, 1, 2, 3, 4, 5]
            sage: el.L(4, 3)
            [6]
            sage: el.L(5, 3)
            [0, 1, 2, 3, 4, 5]
            sage: el.L(6, 3)
            [6]

            sage: el = LatticeSpaceElementOverQQ(L, (1/2, 1/2, 0, 0, 0, 1/3, 1/3))
            sage: el.L(1, 2)
            []
            sage: el.L(2, 2)
            []
            sage: el.L(3, 2)
            []
            sage: el.L(4, 2)
            [2]
            sage: el.L(5, 2)
            []
            sage: el.L(6, 2)
            [2]
            sage: el.L(1, 3)
            [0, 1, 2, 3, 4, 5]
            sage: el.L(2, 3)
            []
            sage: el.L(3, 3)
            [0, 1, 2, 3, 4, 5]
            sage: el.L(4, 3)
            []
            sage: el.L(5, 3)
            [0, 1, 2, 3, 4, 5]
            sage: el.L(6, 3)
            []

        """
        if p==2:
            return [i for i in self.H(p)['H']
                    if (self.integral_parent().valuation(i,p)-k) < 0 and is_odd(self.integral_parent().valuation(i,p)-k)]
        else:
            return [i for i in self.H(p)
                    if (self.integral_parent().valuation(i,p)-k) < 0 and is_odd(self.integral_parent().valuation(i,p)-k)]

    def l(self, k, p):
        """
        An invariant from [Kudla, Yang - Eisenstein Series for SL(2)].
        Used in the computation of Eisenstein series for the parent lattice and the Weil representation.
        Returns the length of the list self.L(k, p).

        INPUT:
            `k` -- an integer
        
            `p` -- a positive prime number

        OUTPUT:
            a non-negative integer

        EXAMPLES::

            sage: m = diagonal_matrix([2, 4, 8])
            sage: m = m.block_sum(2 * matrix(2,2,[0,1,1,0]))
            sage: m = m.block_sum(4 * matrix(2,2,[2,1,1,2]))
            sage: L = Lattice(m)

            sage: el = LatticeSpaceElementOverQQ(L, (0, 0, 0, 0, 0, 0, 0))
            sage: el.l(1, 2)
            0
            sage: el.l(2, 2)
            1
            sage: el.l(3, 2)
            1
            sage: el.l(4, 2)
            2
            sage: el.l(5, 2)
            1
            sage: el.l(6, 2)
            2
            sage: el.l(1, 3)
            6
            sage: el.l(2, 3)
            1
            sage: el.l(3, 3)
            6
            sage: el.l(4, 3)
            1
            sage: el.l(5, 3)
            6
            sage: el.l(6, 3)
            1

            sage: el = LatticeSpaceElementOverQQ(L, (1/2, 1/2, 0, 0, 0, 1/3, 1/3))
            sage: el.l(1, 2)
            0
            sage: el.l(2, 2)
            0
            sage: el.l(3, 2)
            0
            sage: el.l(4, 2)
            1
            sage: el.l(5, 2)
            0
            sage: el.l(6, 2)
            1
            sage: el.l(1, 3)
            6
            sage: el.l(2, 3)
            0
            sage: el.l(3, 3)
            6
            sage: el.l(4, 3)
            0
            sage: el.l(5, 3)
            6
            sage: el.l(6, 3)
            0

        """
        return len(self.L(k,p))

    def d(self, k, p):
        """
        An invariant from [Kudla, Yang - Eisenstein Series for SL(2)].
        Used in the computation of Eisenstein series for the parent lattice and the Weil representation.

        INPUT:
            `k` -- an integer
        
            `p` -- a positive prime number

        OUTPUT:
            a half-integer

        EXAMPLES::

            sage: m = diagonal_matrix([2, 4, 8])
            sage: m = m.block_sum(2 * matrix(2,2,[0,1,1,0]))
            sage: m = m.block_sum(4 * matrix(2,2,[2,1,1,2]))
            sage: L = Lattice(m)

            sage: el = LatticeSpaceElementOverQQ(L, (0, 0, 0, 0, 0, 0, 0))
            sage: el.d(1, 2)
            1
            sage: el.d(2, 2)
            1/2
            sage: el.d(3, 2)
            -3/2
            sage: el.d(4, 2)
            -4
            sage: el.d(5, 2)
            -13/2
            sage: el.d(6, 2)
            -9
            sage: el.d(1, 3)
            -2
            sage: el.d(2, 3)
            -9/2
            sage: el.d(3, 3)
            -7
            sage: el.d(4, 3)
            -19/2
            sage: el.d(5, 3)
            -12
            sage: el.d(6, 3)
            -29/2
            1

            sage: el = LatticeSpaceElementOverQQ(L, (1/2, 1/2, 0, 0, 0, 1/3, 1/3))
            sage: el.d(1, 2)
            1
            sage: el.d(2, 2)
            1
            sage: el.d(3, 2)
            0
            sage: el.d(4, 2)
            -3/2
            sage: el.d(5, 2)
            -3
            sage: el.d(6, 2)
            -9/2
            sage: el.d(1, 3)
            -2
            sage: el.d(2, 3)
            -4
            sage: el.d(3, 3)
            -6
            sage: el.d(4, 3)
            -8
            sage: el.d(5, 3)
            -10
            sage: el.d(6, 3)
            -12
        
        """
        if p==2:
            return (k
                    + sum([min([self.integral_parent().valuation(i,p)-k,0]) for i in self.H(p)['H']])/Integer(2)
                    + sum([min([self.integral_parent().valuation(i,p)-k,0]) for i in self.H(p)['M']])
                    + sum([min([self.integral_parent().valuation(i,p)-k,0]) for i in self.H(p)['N']]))
        else:
            return k + sum([min([self.integral_parent().valuation(i,p)-k,0]) for i in self.H(p)])/Integer(2)

    def eps(self, k, p):
        """
        An invariant from [Kudla, Yang - Eisenstein Series for SL(2)].
        Used in the computation of Eisenstein series for the parent lattice and the Weil representation.
        Returns -1 or 1 if p != 2 and an integer otherwise.

        INPUT:
            `k` -- an integer
        
            `p` -- a positive prime number

        OUTPUT:
            an integer

        EXAMPLES::

            sage: m = diagonal_matrix([3*2, 5*4, 7*8, 11*8, 13*16])
            sage: m = m.block_sum(4 * matrix(2,2,[2,1,1,2]))

            sage: el = LatticeSpaceElementOverQQ(L, (0, 0, 0, 0, 0, 0, 0))
            sage: el.eps(1,2)
            1
            sage: el.eps(2,2)
            1
            sage: el.eps(3,2)
            1
            sage: el.eps(4,2)
            9
            sage: el.eps(5,2)
            1
            sage: el.eps(6,2)
            9
            sage: el.eps(1,3)
            -1
            sage: el.eps(2,3)
            1
            sage: el.eps(3,3)
            -1
            sage: el.eps(4,3)
            1
            sage: el.eps(5,3)
            -1
            sage: el.eps(6,3)
            1

            sage: el = LatticeSpaceElementOverQQ(L, (0, 0, 1/2, 0, 0, 1/3, 1/3))
            sage: el.eps(1,2)
            1
            sage: el.eps(2,2)
            1
            sage: el.eps(3,2)
            1
            sage: el.eps(4,2)
            1
            sage: el.eps(5,2)
            1
            sage: el.eps(6,2)
            1
            sage: el.eps(1,3)
            -1
            sage: el.eps(2,3)
            1
            sage: el.eps(3,3)
            -1
            sage: el.eps(4,3)
            1
            sage: el.eps(5,3)
            -1
            sage: el.eps(6,3)
            1
        
        """
        if p==2:
            return prod([self.integral_parent().unit(j, p) for j in self.L(k, p)])
        else:
            return ((self.modified_hilbert_symbol(-1,p)**floor((self.l(k,p)/2)))
                    * prod([self.modified_hilbert_symbol(self.integral_parent().unit(i,p),p) for i in self.L(k,p)]))

    def multiplicity(self, p):
        n = self.integral_parent().dimension()
        if p==2:
            if n == len(self.H(p)['H'])+2*len(self.H(p)['M'])+2*len(self.H(p)['N']):
                return Infinity
            else:
                [odds, even_I, even_II] = self.integral_parent().sort_2_adic()
                return p**(min([self.integral_parent().valuation(i,p) + self._mu_p_i(p,i).valuation(p)
                             for i in odds if i not in self.H(p)['H']]
                            + [self.integral_parent().valuation(i,p)
                               + min([self._mu_p_i(p,i).valuation(p), self._mu_p_i(p,i+1).valuation(p)])
                               for i in even_I[0::2] if i not in self.H(p)['M']]
                            + [self.integral_parent().valuation(i,p)
                               + min([self._mu_p_i(p,i).valuation(p), self._mu_p_i(p,i+1).valuation(p)])
                               for i in even_II[0::2] if i not in self.H(p)['N']]))
        else:
            if n == len(self.H(p)):
                return Infinity
            else:
                return p**self.K0(p)
            
    def K0(self, p):
        """
        An invariant from [Kudla, Yang - Eisenstein Series for SL(2)].
        Used in the computation of Eisenstein series for the parent lattice and the Weil representation.

        INPUT:
            `p` -- a positive prime number

        OUTPUT:
            an integer

        EXAMPLES::

            sage: m = diagonal_matrix([2, 4, 8])
            sage: m = m.block_sum(2 * 3 * matrix(2,2,[0,1,1,0]))
            sage: m = m.block_sum(4 * 9 * matrix(2,2,[2,1,1,2]))
            sage: L = Lattice(m)
            sage: el = LatticeSpaceElementOverQQ(L, (0, 0, 0, 0, 0, 0, 0))
            sage: el.K0(2)
            +Infinity
            sage: el.K0(3)
            +Infinity
            sage: el = LatticeSpaceElementOverQQ(L, (1/2, 1/2, 0, 0, 0, 1/3, 1/3))
            sage: el.K0(2)
            1
            sage: el.K0(3)
            2
            sage: el = LatticeSpaceElementOverQQ(L, (1/2, 1/2, 1/8, 0, 0, 1/3, -1/3))
            sage: el.K0(2)
            0
            sage: el.K0(3)
            1
        
        """
        n = self.integral_parent().dimension()
        if p==2:
            if n == len(self.H(p)['H'])+2*len(self.H(p)['M'])+2*len(self.H(p)['N']):
                return Infinity
            else:
                [odds, even_I, even_II] = self.integral_parent().sort_2_adic()
                return (min([self.integral_parent().valuation(i,p) + self._mu_p_i(p,i).valuation(p)
                             for i in odds if self._mu_p_i(p,i).valuation(p) < -1]
                            + [self.integral_parent().valuation(i,p) for i in odds if self._mu_p_i(p,i).valuation(p) == -1]
                            + [self.integral_parent().valuation(i,p)
                               + min([self._mu_p_i(p,i).valuation(p), self._mu_p_i(p,i+1).valuation(p)])
                               for i in even_I[0::2] if i not in self.H(p)['M']]
                            + [self.integral_parent().valuation(i,p)
                               + min([self._mu_p_i(p,i).valuation(p), self._mu_p_i(p,i+1).valuation(p)])
                               for i in even_II[0::2] if i not in self.H(p)['N']]))
        else:
            if n == len(self.H(p)):
                return Infinity
            else:
                return min([self.integral_parent().valuation(i,p) + self._mu_p_i(p,i).valuation(p)
                            for i in range(n) if i not in self.H(p)])

    def p(self, k):
        """
        An invariant from [Kudla, Yang - Eisenstein Series for SL(2)].
        Used in the computation of Eisenstein series for the parent lattice and the Weil representation.
        This invariant is only used in the 2-adic case and equals -1 or 1.

        INPUT:
            `k` -- an integer

        OUTPUT:
            -1 or 1

        EXAMPLES::

            sage: m = diagonal_matrix([2, 4, 8])
            sage: m = m.block_sum(2 * 3 * matrix(2,2,[0,1,1,0]))
            sage: m = m.block_sum(4 * 9 * matrix(2,2,[2,1,1,2]))
            sage: L = Lattice(m)
        
            sage: el = LatticeSpaceElementOverQQ(L, (0, 0, 0, 0, 0, 0, 0))
            sage: el.p(1)
            1
            sage: el.p(2)
            1
            sage: el.p(3)
            -1
            sage: el.p(4)
            1
            sage: el.p(5)
            -1
            sage: el.p(6)
            1

            sage: el = LatticeSpaceElementOverQQ(L, (0, 0, 0, 0, 0, 1/2, 1/2))
            sage: el.p(1)
            1
            sage: el.p(2)
            1
            sage: el.p(3)
            1
            sage: el.p(4)
            1
            sage: el.p(5)
            1
            sage: el.p(6)
            1
        
        """
        return (-1)**sum([min([self.integral_parent().valuation(i,2)-k,0]) for i in self.H(2)['N']])

    def delta(self, k):
        """
        An invariant from [Kudla, Yang - Eisenstein Series for SL(2)].
        Used in the computation of Eisenstein series for the parent lattice and the Weil representation.
        This invariant is only used in the 2-adic case and equals 0 or 1.

        INPUT:
            `k` -- an integer

        OUTPUT:
            0 or 1

        EXAMPLES::

            sage: m = diagonal_matrix([2, 4, 8])
            sage: m = m.block_sum(2 * 3 * matrix(2,2,[0,1,1,0]))
            sage: m = m.block_sum(4 * 9 * matrix(2,2,[2,1,1,2]))
            sage: L = Lattice(m)
        
            sage: el = LatticeSpaceElementOverQQ(L, (0, 0, 0, 0, 0, 0, 0))
            sage: el.delta(1)
            0
            sage: el.delta(2)
            0
            sage: el.delta(3)
            0
            sage: el.delta(4)
            1
            sage: el.delta(5)
            1
            sage: el.delta(6)
            1

            sage: el = LatticeSpaceElementOverQQ(L, (1/2, 0, 0, 0, 0, 0, 0))
            sage: el.delta(1)
            1
            sage: el.delta(2)
            0
            sage: el.delta(3)
            0
        
            sage: el = LatticeSpaceElementOverQQ(L, (0, 1/2, 0, 0, 0, 0, 0))
            sage: el.delta(1)
            0
            sage: el.delta(2)
            1
            sage: el.delta(3)
            0
        
            sage: el = LatticeSpaceElementOverQQ(L, (0, 0, 1/2, 0, 0, 0, 0))
            sage: el.delta(1)
            0
            sage: el.delta(2)
            0
            sage: el.delta(3)
            1
        
        """
        for j in self.H(2)['H']:
            if k == self.integral_parent().valuation(j,2):
                return 0
        return 1
            
    def modified_hilbert_symbol(self, a, p):
        """
        Returns 0 if a is not a unit in Zp(p), else return the Hilbert symbol (a,p)_p.

        INPUT:
            `a` -- an integer
        
            `p` -- a positive prime number

        OUTPUT:
            -1, 0 or 1

        EXAMPLES::

            sage: m = diagonal_matrix([3*2, 5*4, 7*8, 11*8, 13*16])
            sage: m = m.block_sum(4 * matrix(2,2,[2,1,1,2]))

            sage: el = LatticeSpaceElementOverQQ(L, (0, 0, 0, 0, 0, 0, 0))
            sage: el.modified_hilbert_symbol(1,2)
            1
            sage: el.modified_hilbert_symbol(0,2)
            0
            sage: el.modified_hilbert_symbol(1,2)
            1
            sage: el.modified_hilbert_symbol(2,2)
            0
            sage: el.modified_hilbert_symbol(3,2)
            -1
            sage: el.modified_hilbert_symbol(4,2)
            0
            sage: el.modified_hilbert_symbol(5,2)
            -1
            sage: el.modified_hilbert_symbol(6,2)
            0
            sage: el.modified_hilbert_symbol(7,2)
            1
        
        """
        if Zp(p)(a).is_unit():
            return hilbert_symbol(a,p,p)
        else:
            return 0
            
    def f1(self, x, p):
        """
        An invariant from [Kudla, Yang - Eisenstein Series for SL(2)].
        Used in the computation of Eisenstein series for the parent lattice and the Weil representation.

        INPUT:
            `x` -- an integer
        
            `p` -- a positive prime number

        OUTPUT:
            -1/p, -1/sqrt(p) or 1/sqrt(p)

        EXAMPLES::

            sage: m = 2 * diagonal_matrix([3,9,27,81])
            sage: L = Lattice(m)
            sage: el = LatticeSpaceElementOverQQ(L, (0, 0, 0, 0))
            sage: el.f1(1 * 3**0, 3)
            -1/3
            sage: el.f1(1 * 3**1, 3)
            1/3*sqrt(3)
            sage: el.f1(2 * 3**1, 3)
            -1/3*sqrt(3)

        """
        a=valuation(x,p)
        if is_even(self.l(a+1,p)):
            return -1/p
        else:
            return self.modified_hilbert_symbol(x * p**-a,p)/sqrt(p)

    def t(self, m, p):
        """
        An invariant from [Kudla, Yang - Eisenstein Series for SL(2)].
        Used in the computation of Eisenstein series for the parent lattice and the Weil representation.
        Returns `m` minus the quadratic form evaluated at those coordinates of self that are not in the list
        `H`, `M` or `N` (the listst that point to (pairs of) coordinates that are p-adic integers).

        INPUT:
            `m` -- a rational
        
            `p` -- a positive prime number

        OUTPUT:
            a rational

        EXAMPLES::

            sage: m = 2 * diagonal_matrix([3,9,27,81])
            sage: L = Lattice(m)
            sage: el = LatticeSpaceElementOverQQ(L, (0, 0, 0, 0))
            sage: el.t(0, 3)
            0
            sage: el.t(0, 2)
            0

            sage: el = LatticeSpaceElementOverQQ(L, (1, 1, 1, 1))
            sage: el.t(0, 3)
            0
            sage: el.t(0, 2)
            0

            sage: el = LatticeSpaceElementOverQQ(L, (1/2, 1, 1, 1))
            sage: el.t(0, 3)
            0
            sage: el.t(0, 2)
            -3/4
            sage: el.t(1, 2)
            1/4

            sage: el = LatticeSpaceElementOverQQ(L, (1/3, 1, 1, 1))
            sage: el.t(0, 3)
            -1/3
            sage: el.t(1, 3)
            2/3
            sage: el.t(0, 2)
            0

        """
        n = self.integral_parent().dimension()
        if p==2:
            [odds, even_I, even_II] = self.integral_parent().sort_2_adic()
            return (m
                    - sum([self.integral_parent().unit(i,p)*p**(self.integral_parent().valuation(i,p)-1)
                           *(self._mu_p_i(p,i))**2
                           for i in odds if i not in self.H(p)['H']])
                    - sum([p**(self.integral_parent().valuation(i,p))
                           *(self._mu_p_i(p,i) * self._mu_p_i(p,i+1))
                           for i in even_I[0::2] if i not in self.H(p)['M']])
                    - sum([p**(self.integral_parent().valuation(i,p))
                           *(self._mu_p_i(p,i)**2 + self._mu_p_i(p,i) * self._mu_p_i(p,i+1) + self._mu_p_i(p,i+1)**2)
                           for i in even_II[0::2] if i not in self.H(p)['N']])
                    )
        else:
            return (m
                    - sum([self.integral_parent().unit(i,p)*p**(self.integral_parent().valuation(i,p))
                           *(self._mu_p_i(p,i))**2
                           for i in range(n) if i not in self.H(p)])
                    )

    def nu(self, m, k):
        """
        An invariant from [Kudla, Yang - Eisenstein Series for SL(2)].
        Used in the computation of Eisenstein series for the parent lattice and the Weil representation.
        This invariant is only used in the 2-adic case.

        INPUT:
            `m` -- a rational
         
            `k` -- an integer

        OUTPUT:
            a rational

        EXAMPLES::

            sage: m = diagonal_matrix([101 * 2, 10001 * 4, 1000001 * 8])
            sage: L = Lattice(m)
            sage: el = LatticeSpaceElementOverQQ(L, (0, 0, 0))
            sage: el.nu(0,1)
            0
            sage: el.nu(1,1)
            4
            sage: el.nu(2,1)
            8
            sage: el.nu(0,2)
            -101
            sage: el.nu(0,3)
            -10102
            sage: el.nu(0,4)
            -1010103

        """
        return (self.t(m, 2) * 2**(Integer(3)-k)
                - sum([self.integral_parent().unit(j,2)
                       for j in self.H(2)['H']
                       if self.integral_parent().valuation(j,2) < k])
                )

    #@cached_method
    def Wpoly(self, p, m, verbose=False):
        """
        Returns a polynomial or rational function corresponding to the local Whittaker
        (cnf. local densities) function as described in [Kudla, Yang - Eisenstein Series for SL(2)].
        
        INPUT:
            `p` -- a positive prime number
        
            `m` -- a rational number

        OUTPUT:
            a polynomial or rational function in one variable.

        EXAMPLES::

            sage: L = Lattice(ZZ, 1, [1])
            sage: el = LatticeSpaceElementOverQQ(L, (0,))
            sage: el.Wpoly(2,1/2)
            0
        
            sage: el.Wpoly(2,0)
            (-X^2 + 1)/(-2*X^2 + 1)
            sage: el.Wpoly(2,1)
            2*X^3 + X^2 + 1
            sage: el.Wpoly(2,2)
            -X^2 + 1
            sage: el.Wpoly(2,3)
            -X^2 + 1
            sage: el.Wpoly(2,4)
            4*X^5 + 2*X^4 + X^2 + 1
            sage: el.Wpoly(2,5)
            -2*X^3 + X^2 + 1
            sage: el.Wpoly(2,6)
            -X^2 + 1

            sage: m = 2 * diagonal_matrix([3,9,27,81])
            sage: L = Lattice(m)
            sage: el = LatticeSpaceElementOverQQ(L, (0, 0, 0, 1/3))
            sage: el.Wpoly(3,1)
            -X + 1
            sage: el.Wpoly(3,2)
            -X + 1
            sage: el.Wpoly(3,3)
            3*X^2 + 2*X + 1
            sage: el.Wpoly(3,4)
            -X + 1
            sage: el.Wpoly(3,5)
            -X + 1
            sage: el.Wpoly(3,6)
            -3*X^2 + 2*X + 1
            sage: el.Wpoly(3,7)
            -X + 1
            sage: el.Wpoly(3,8)
            -X + 1
            sage: el.Wpoly(3,9)
            2*X + 1 

        """
        R = PolynomialRing(QQ, 'X')
        if (m-self.Q()).valuation(p) < 0:
            return R(0)
            
        t=self.t(m,p)
        a = valuation(t,p)
        n = self.integral_parent().dimension()
        #print "n:", n, type(n)
        if verbose:
            print "t=",t
            print "a=",a
        XX = R.gen()

        if p==2:
            
            k0 = min(self.K0(p), a+3)
            if verbose:
                print "k0=", k0
            if k0 < Infinity:
                result = R(1)
                for k in range(1, k0+1):
                    if is_even(self.l(k,p)):
                        if verbose:
                            print "k=", k
                            print "delta=", self.delta(k)
                            print "L=", self.L(k,p)
                            print "l=", self.l(k,p)
                            print "d=", self.d(k,p)
                            print "d-1=", self.d(k,p) - 1
                            print "eps=", self.eps(k,p)
                            print "nu",type(self.nu(m,k)), self.nu(m,k), Integer(Zp(2)(self.nu(m,k)))
                        if self.nu(m,k).valuation(2) >= 3:  #This does not work porperly: self.nu(m, k) % 8 == 0:
                            result += (self.delta(k) * self.p(k) * 2**Integer(self.d(k,p)-1)
                                       * kronecker_symbol(2, self.eps(k,p)) * XX**k
                                       )
                        elif (self.nu(m,k)-4).valuation(2) >= 3:  #This does not work porperly: self.nu(m, k) % 8 == 4:
                            result -= (self.delta(k) * self.p(k) * 2**Integer(self.d(k,p)-1)
                                       * kronecker_symbol(2, self.eps(k,p)) * XX**k
                                       )
                    else:
                        if verbose:
                            print "k=", k
                            print "delta=", self.delta(k)
                            print "L=", self.L(k,p)
                            print "l=", self.l(k,p)
                            print "d=", self.d(k,p)
                            print "d-3/2=", self.d(k,p) - 3/Integer(2)
                            print "eps=", self.eps(k,p)
                            print "nu",type(self.nu(m,k)), self.nu(m,k), Integer(Zp(2)(self.nu(m,k)))
                        result += (self.delta(k) * self.p(k) * 2**Integer(self.d(k,p)-3/Integer(2))
                                   * kronecker_symbol(2, self.eps(k,p)*Integer(Zp(2)(self.nu(m,k)))) * XX**k
                                   )
                return result
            else:
                l = max(self.integral_parent().valuation(i,p) for i in range(n))
                #From k0 to K0=Infinity, the above "sum" is a geometric series.
                #For simplicity in the following code, k0 is even: 
                k0 = l+1+(l+1)%2

                result = R(1)
                for k in range(1, k0):
                    if is_even(self.l(k,p)):
                        if self.nu(m, k) % 8 == 0:
                            result += (self.delta(k) * self.p(k) * 2**Integer(self.d(k,p)-1)
                                       * kronecker_symbol(2, self.eps(k,p)) * XX**k
                                       )
                        elif self.nu(m, k) % 8 == 4:
                            result -= (self.delta(k) * self.p(k) * 2**Integer(self.d(k,p)-1)
                                       * kronecker_symbol(2, self.eps(k,p)) * XX**k
                                       )
                    else:
                        result += (self.delta(k) * self.p(k) * 2**Integer(self.d(k,p)-3/Integer(2))
                                   * kronecker_symbol(2, self.eps(k,p)*Integer(Zp(2)(self.nu(m,k)))) * XX**k
                                   )
                        
                l_even = self.l(k0,p)
                l_odd = self.l(k0+1,p)
                d = sum(self.integral_parent().valuation(i,p) for i in self.H(p)['H'])/Integer(2)
                d += sum(self.integral_parent().valuation(i,p) for i in self.H(p)['M'])
                d += sum(self.integral_parent().valuation(i,p) for i in self.H(p)['N'])
                eps_even = self.eps(k0,p)
                eps_odd = self.eps(k0+1,p)
                p_even = self.p(k0)
                p_odd = self.p(k0+1)
                nu_even_odd = Integer(self.nu(m, k0)) % 8
                if nu_even_odd == 0:
                    psi_times_char_nu = +1
                elif nu_even_odd == 4:
                    psi_times_char_nu = -1
                else:
                    psi_times_char_nu = 0
                    
                # In the following cases we evaluate (the meromorphic extension of) the geometric series for even resp. odd k
                if l_even % 2 == 0:
                    result += (p_even * p**Integer(d-1 + (1-n/2)*k0)
                               * kronecker_symbol(2, eps_even)
                               * psi_times_char_nu * XX**k0
                               / (1 - p**(2-n) * XX**2)
                               )
                else:
                    result += (p_even * p**Integer(d-3/Integer(2) + (1-n/2)*k0)
                               * kronecker_symbol(2, eps_even * nu_even_odd) * XX**k0
                               / (1 - p**(2-n) * XX**2)
                               )
                if l_odd % 2 == 0:
                    result += (p_odd * p**Integer(d-1 + (1-n/2)*(k0+1))
                               * kronecker_symbol(2, eps_odd)
                               * psi_times_char_nu * XX**(k0+1)
                               / (1 - p**(2-n) *XX**2)
                               )
                else:
                    result += (p_odd * p**Integer(d-3/Integer(2) + (1-n/2)*(k0+1))
                               * kronecker_symbol(2, eps_odd * nu_even_odd) * XX**(k0+1)
                               / (1 - p**(2-n) * XX**2)
                               )
                return result
                        
        else:
            
            if a >= 0  and a < self.K0(p):
                result = (R(1)
                          + R(1-1/Integer(p)) * sum([self.eps(k,p)*(p**self.d(k,p))*XX**k
                                                     for k in range(1,a+1) if is_even(self.l(k,p))])
                          )
                result += self.eps(a+1,p)*R(self.f1(t,p)*p**self.d(a+1,p))*XX**(a+1)

                return result
            elif self.K0(p) < Infinity:
                return (R(1)
                        + R(1-1/Integer(p)) * sum([self.eps(k,p)*(p**self.d(k,p))*XX**k
                                                   for k in range(1,self.K0(p)+1) if is_even(self.l(k,p))])
                        )
            else:
                l = max(self.integral_parent().valuation(i,p) for i in range(n))
                #From k0 to K0=Infinity, the above "sum" is a geometric series.
                #For simplicity in the following code, k0 is even:
                k0 = l+1+(l+1)%2
                l_even = self.l(k0,p)
                l_odd = self.l(k0+1,p)
                d = sum(self.integral_parent().valuation(i,p) for i in self.H(p))/Integer(2)
                result = (R(1)
                          + QQ(1-1/Integer(p)) * sum([self.eps(k,p)*(p**self.d(k,p))*XX**k
                                                      for k in range(1,k0) if is_even(self.l(k,p))])
                          )
                eps_even = self.eps(k0,p)
                eps_odd = self.eps(k0+1,p)
                    
                # In the following cases we evaluate (the meromorphic extension of) the geometric series for even resp. odd k
                if l_even % 2 == 0:
                    #print "Place" + 20*"4"
                    result += (R(1-1/Integer(p)) * eps_even
                               * p**Integer(d+(1-n/2)*k0) * XX**k0
                               / (1 - p**(2-n) * XX**2)
                               )
                if l_odd % 2 == 0:
                    #print "Place" + 20*"5"
                    result += (R(1-1/Integer(p)) * eps_odd
                               * p**Integer(d+(1-n/2)*(k0+1)) * XX**(k0+1)
                               / (1 - p**(2-n) *XX**2)
                               )
                return result
            
        raise RuntimeError, "A result should already have been returend."

    def W(self, p, m, s, min_precision=53):
        """
        Evaluates the local Whittaker (cnf. local densities) function as described in
        [Kudla, Yang - Eisenstein Series for SL(2)] at p**-s.
        
        INPUT:
            `p` -- a positive prime number
        
            `m` -- a rational number

            `s` -- an integer, a rational or a complex number

        OUTPUT:
            a number (mostly complex or rational, depending on the input)

        EXAMPLES::

            sage: L = Lattice(ZZ, 1, [1])
            sage: el = LatticeSpaceElementOverQQ(L, (0,))
            sage: el.W(2,1/2,4)
            0
        
            sage: el.W(2,1,4)
            2057/2048
            sage: el.W(2,2,4)
            255/256
            sage: el.W(2,3,4)
            255/256
            sage: el.W(2,4,4)
            263177/262144
            sage: el.W(2,5,4)
            2055/2048
            sage: el.W(2,6,4)
            255/256

            sage: m = 2 * diagonal_matrix([3,9,27,81])
            sage: L = Lattice(m)
            sage: el = LatticeSpaceElementOverQQ(L, (0, 0, 0, 1/3))
            sage: el.W(3,1,8)
            6560/6561
            sage: el.W(3,2,8)
            6560/6561
            sage: el.W(3,3,8)
            14353282/14348907
            sage: el.W(3,4,8)
            6560/6561
            sage: el.W(3,5,8)
            6560/6561
            sage: el.W(3,6,8)
            14353280/14348907
            sage: el.W(3,7,8)
            6560/6561
            sage: el.W(3,8,8)
            6560/6561
            sage: el.W(3,9,8)
            6563/6561

            sage: abs(el.W(3,9,1/2) - 2.15470053837925) < 2**-40
            True
            sage: el.W(3,9,1/2).prec()
            54


        """
        wpoly = self.Wpoly(p, m)
        
        if type(s) == sage.rings.complex_number.ComplexNumber:
            return wpoly(p**(-s))
            
        if type(wpoly) == sage.rings.polynomial.polynomial_rational_flint.Polynomial_rational_flint and (type(s) == sage.rings.rational.Rational or type(s) == sage.rings.integer.Integer):
            
            sden = (-s).denominator()
            snum = (-s).numerator()
            X = wpoly.parent().gen()

            # The polynomial X**sden - p**snum is irreducible, thus we reduce wpoly by it to take a closer look at wpoly(p**(snum/sden))
            resultpoly = wpoly % (X**sden - p**snum)

            assert wpoly(p**-s)==resultpoly(p**-s)

            wpoly = resultpoly
            
            if wpoly.is_constant():
                return wpoly.constant_coefficient()
                
        if min_precision < 0:
            raise ValueError, "precision is less than 0. Given: {0}".format(min_precision)
                
        prec = max(0,log(abs(wpoly(p**-s)), 2)) + min_precision
        resultcomplex = ComplexField(prec)(wpoly(p**-s))

        return resultcomplex

    def Wpoly_invariants(self, p):
        order = LCM([j.denominator() for j in self.list()])
        order = p**valuation(order, p)
        Qfloor = self.Q() - floor(self.Q())
        invariants = []
        k0 = self.K0(p)
        if k0 == Infinity:
            k0 = 0
        elif p==2:
            k0 = 2*self.multiplicity(2)
        else:
            k0 = p**k0
        for m in range(k0):
            invariants += [(m + Qfloor, self.Wpoly(p, m + Qfloor))]
        return invariants
        
#    def W_archimedean(self, l, m, s, tau):
#        alpha = (s + 1 + l)/Integer(2)
#        beta = (s + 1 - l)/Integer(2)
#        Q = PolynomialRing(QQ, 'q')
#        qq = R.gen()
#        if m > 0:
#            pass

    def representation_number_Bruinier_Kuss(self, n, a):
        nn = QQ(n)
        aa = Integer(a)
        L = self.integral_parent()
        result = Integer(0)
        for r in itertools.product(*[range(a) for j in range(L.dim())]):
            if ((nn + (L(r) - self).Q()) / aa) in ZZ:
                result += 1
        return result
        
            
#class LatticeElement(LatticeSpaceElementOverQQ):
#
#    def __init__(self, parent, entries):
#        if not(isinstance(parent, Lattice)):
#            raise TypeError, "The parent must be a Lattice."
#        FreeModuleElement_generic_dense.__init__(self, parent, entries)
#        self.Q = parent.Q(self)
#
#    def __add__(self, other):
#        print isinstance(other, LatticeElement)
#        print self.parent()
#        print other.parent()
#        print other.parent() == self.parent()
#        #print other.parent() eq self.parent()
#        if isinstance(other, LatticeElement) and other.parent() == self.parent():
#            print "We are here!"
#            return LatticeElement(self.parent(), (self.row().row(0) + other.row().row(0)).list())
#        elif False:
#            pass
#        else:
#            print "this should not happen now!"
#            return FreeModuleElement_generic_dense.__add__(self, other)

def A(n, scale=1):
    M = zero_matrix(n,n+1)
    M[:,:n] -= identity_matrix(n)
    M[:,1:] += identity_matrix(n)
    gram_mat = M * M.transpose()
    #print M, "\n\n", gram_mat, "\n"
    return Lattice(gram_mat)(scale)

def D(n, scale=1):
    assert n >= 3
    M = - identity_matrix(n)
    M[0,1] = -1
    M[1:,:-1] += identity_matrix(n-1)
    gram_mat = M * M.transpose()
    #print M, "\n\n", gram_mat, "\n"
    return Lattice(gram_mat)(scale)

def E(n,scale=1):
    assert n in [6,7,8]
    M = identity_matrix(QQ, 8)
    M[1:7,:6] -= identity_matrix(6)
    M[0,0] = 2
    M[7,:] = matrix(1,8,[1/Integer(2) for j in range(8)])
    if n <= 7:
        M = M[1:,:]
        M[6,4:] = matrix(1,4,[-1/Integer(2) for j in range(4)])
    if n == 6:
        M = M[1:,:]
    gram_mat = (M * M.transpose()).change_ring(ZZ)
    #print M, "\n\n", gram_mat, "\n"
    return Lattice(gram_mat)(scale)

def H(scale=1):
    return Lattice(ZZ, 2, [0,1,0])(scale)

def O_D(D, scale=1):
    if D % 4 in [0,1]:
        d = D
    else:
        d = 4 * D
    return Lattice(matrix(2,2,[2,d,d,Integer(Integer(d**2 - d)/Integer(2))]))(scale)

def U(scale=1):
    return H(scale)
    
def representation_number_Bruinier_Kuss_theoretical(N, gamma1, gamma2, n, p, nu):
    if not (gamma1 in ZZ and gamma2 in ZZ):
        raise ValueError
    if N == 1:
        if n in ZZ:
            v = valuation(n,p)
            if v < nu:
                return Integer((v + 1)*(p**nu - p**(nu-1)))
            else:
                return Integer(nu*(1 - 1/p)*p**nu + p**nu)
        else:
            return Integer(0)
    else:
        nu_N = valuation(N, p)
        nu_gamma = min(valuation(gamma1, p), valuation(gamma2, p))
        l = n + gamma1 * gamma2 / Integer(N)
        if not l in ZZ:
            return 0
        if min(nu, nu_gamma, nu_N) > valuation(l, p):
            return 0
        if min(nu, nu_gamma) >= nu_N:
            n_tilde = N * n / p**(2*nu_N)
            return p**(2*nu_N) * representation_number_Bruinier_Kuss_theoretical(1, 0, 0, n_tilde, p, nu - nu_N)
        else:
            return p**(nu + min(nu,nu_gamma))
        
def quadratic_L_function__exact__extended(s, D):
    if Mod(D, 4) != 0 and Mod(D, 4) != 1:
        return 0
    else:
        if D == 0:
            return zeta__exact(2 * s - 1)
        else:
            X = PolynomialRing(QQ,'X').gen()
            f = X**2 - D
            ft = f.factor()
            #print "L(s,D):"
            #print ft,"\n"
            if ft[0][0].degree() != 0:
                f = ft[0][0]
            else:
                f = ft[1][0]
            #print f,"\n"
            K = NumberField(f, 'x')
            x = K.gen()
            D_0 = K.disc()
            #print D_0,"\n"
            fs = sqrt(ZZ(D / D_0))
            #print fs,"\n"
            res = quadratic_L_function__exact(s, D_0)
            #print res,"\n"
            terms = [moebius(d) * kronecker_symbol(D_0, d) * d**(-s) * sigma(fs / d, 1 - 2 * s) for d in fs.divisors()]
            #print fs.divisors()
            #print terms
            res *= sum(terms)
    return res
            
def jacobi_eisenstein_series_coefficient(k, m, n, r, verbose=False):

    m = Integer(m)
    k = Integer(k)
    if k < 4 or k % 2 != 0:
        raise TypeError, "The weight should be even and >=4."

    discriminant = 4 * n * m - r**2
    if verbose:
        print "discriminant:", discriminant
    if discriminant < 0:
        return 0
    elif discriminant == 0:
        if r % (2*m) == 0:
            return 1
        else:
            return 0
    else:
        m_r_gcd = GCD(ZZ(m), ZZ(r))
        if verbose:
            print "m_r_gcd:", m_r_gcd
        E = 0
        for d in itertools.ifilter(lambda x: ((m % x**2 == 0) and is_squarefree(x)), m_r_gcd.divisors()):
            E += moebius(d) \
                 * sum(itertools.imap(lambda x: (x**(k-1) \
                                                 * quadratic_L_function__exact__extended(2-k, ZZ(-discriminant / x**2 / d**2))), \
                                      GCD([n,ZZ(r/d),ZZ(m/d**2)]).divisors()))
            if verbose:
                print "current d, E:", d, E
            #EE = 0
                for x in GCD([n,ZZ(r/d),ZZ(m/d**2)]).divisors():
                    print "x:", x
                    print "2-k:", 2-k
                    print "ZZ(-discriminant / x**2 / d**2):", ZZ(-discriminant / x**2 / d**2)
                    print "L(2-k, ZZ(-discriminant / x**2 / d**2)):", quadratic_L_function__exact__extended(2-k, ZZ(-discriminant / x**2 / d**2))
                    #print "x**(k-1) * L(2-k, ZZ(-discriminant / x**2 / d**2)):", x**(k-1) * L(2-k, ZZ(-discriminant / x**2 / d**2))
                    print "moebius(d):", moebius(d)
                    #print "GCD([n,ZZ(r/d),ZZ(m/d)**2]):", GCD([n,ZZ(r/d),ZZ(m/d)**2])
                    #print "GCD([n,ZZ(r/d),ZZ(m/d)**2]).divisors()", GCD([n,ZZ(r/d),ZZ(m/d)**2]).divisors()
                    #print "itertools.imap(lambda x: x**(k-1) * L(2-k, ZZ(-discriminant / x**2 / d**2)), GCD([n,ZZ(r/d),ZZ(m/d)**2]).divisors()):"
                    #for x in itertools.imap(lambda x: x**(k-1) * L(2-k, ZZ(-discriminant / x**2 / d**2)),GCD([n,ZZ(r/d),ZZ(m/d)**2]).divisors()):
                    #    print x
                    #print "sum:", sum(itertools.imap(lambda x: x**(k-1) * L(2-k, ZZ(-discriminant / x**2 / d**2)), \
                    #                        GCD([n,ZZ(r/d),ZZ(m/d)**2]).divisors()))
                    #print k,m,n,r, "d:", d, "E:", E
        E *= m**(1-k) \
             * prod(itertools.imap(lambda x: 1/(1+x**(1-k)), m.prime_divisors())) \
             / zeta__exact(3 - 2 * k)
        if verbose:
            print "E with factors:", E
            print "m**(1-k):", m**(1-k)
            print "prod(itertools.imap(lambda x: 1/(1+x**(1-k)), m.prime_divisors())):", prod(itertools.imap(lambda x: 1/(1+x**(1-k)), m.prime_divisors()))
            print "1 / zeta__exact(3 - 2 * k):", 1 / zeta__exact(3 - 2 * k)
        #print "E:", E
        return E
    
def eisenstein_series_from_jacobi(k, m, prec=100):
    k = Integer(k)
    m = Integer(m)
    result = dict()
    for r in range(2*m):
        offset = ((-r**2) % (4*m)) / (4*m)
        offset2 = floor(-r**2 / (4*m))
        result[r]=dict()
        for n in range(prec):
            result[r][offset + n] = jacobi_eisenstein_series_coefficient(k, m, n - offset2, r)
    return result

def test(n=10):
    for i in range(-n,n+1):
        for j in range(-n,n+1):
            for k in range(-n,n+1):
                m = matrix(2,2,[2*i,j,j,2*k])
                if m.det() != 0:
                    L = Lattice(m)
                    print L.Q.matrix()
                    for p in prime_range(3,n+1):

                        print "\n"
                        print "--------------------------------------------------------------------------------"
                        print i,j,k,p
                        print "--------------------------------------------------------------------------------"
                        print m
                        print "--------------------------------------------------------------------------------"
                        print "\n"
                        
                        print "Place 1", p, L.Q.matrix(), L.local_normal_form(p)
                        Q, S = L.local_normal_form(p)
                        print "Place 2", Q.matrix, S, L.Q.matrix(), S.transpose()*L.Q.matrix()*S == Q.matrix()
                        if S.transpose()*L.Q.matrix()*S != Q.matrix():
                            return p,m

    return "All tests successfull!"

def test2(max_size=10, max_value = 100, matr=None):
    n = 1
    for _ in range(n):
        msize = floor(random() * max_size) + 1
        m = matrix(msize, msize, [floor(random()*(2 * max_value + 1 )) - max_value for i in range(msize * msize)])
        for x in range(msize):
            if floor(4*random()):
                m[:,x] = (2,3,5,7,11)[floor(5*random())]**floor(3*random()+1) * m[:,x]
        m = m + m.transpose()
        if matr:
            m = matr
        print m
        L = Lattice(m)
        for p in m.det().prime_divisors():
            Q, S = L.local_normal_form(p)
            #print "Place 2", Q.matrix, S, L.Q.matrix(), S.transpose()*L.Q.matrix()*S == Q.matrix()
            if S.transpose()*L.Q.matrix()*S != Q.matrix():
                return p,m
            else:
                print Qp(p)(S.det()).is_padic_unit(), p, "determinant:\n", S.det(), "\n"
    #print "\n"
    #print m
    #print "\n"
    #print Q.matrix()
    #print "\n"
    
    #A = Q.matrix()
    #a=0
    #while a < A.ncols():
    #    if a == A.ncols()-1 or A[a,a+1] == 0:
    #        print matrix(1,1,[A[a,a]]), "\n"
    #        a += 1
    #    else:
    #        print A[a:a+2,a:a+2], "\n"
    #        a += 2                
    
    #print "\n"
    #if S.nrows() <= 3:
    #    print S, "\n\n"
    #    print [S[k,l] for k in range(S.nrows()) for l in range(S.ncols())]
    #print "\n"#, S**-1
    #print S.det()
    #print "\n"
    #print S.transpose()*L.Q.matrix()*S==Q.matrix()
    #print "\n"
    print "All tests successfull!"
    return m, m.det().prime_divisors() #,S


def test3(max_size=5, max_value = 10, matr=None):

    if matr:
        m = matr
    else:
        msize = floor(random() * max_size) + 1
        m = matrix(msize, msize, [floor(random()*(2 * max_value + 1 )) - max_value for i in range(msize * msize)])
        for x in range(msize):
            if floor(4*random()):
                m[:,x] = (2,3,5,7,11)[floor(5*random())]**floor(3*random()+1) * m[:,x]
        m = m + m.transpose()
    print m, m.det()
    L = Lattice(m)
    l = LatticeElement(L, [0 for _ in range(msize)])
    for p in m.det().prime_divisors():
        for j in range(m.det()):
            print p, j/m.det(), l.W(p, 0, j/m.det())
        

def test4(m=2*3*matrix(3,3,[2,1,0,1,2,0,0,0,5])):
    L = Lattice(m)
    n = L.dimension()
    s = Integer(1) + Integer(5)/Integer(10)#*ComplexField(10)(1,0) # + 1 / ComplexField(3000)(log(5)) * ComplexField(3000).pi()*ComplexField(3000)(0,1)#+ Integer(-1)/10**31 #+CC (Integer(-1)/10**6, Integer(-1)/10**6)
    #print "s:", s
    print L.Q.matrix()
    ps = m.det().prime_factors()
    to_go = abs(m.det())
    #stop = 0
    with open('testresults', 'r+') as f:
        f.seek(0,2)
        f.write('\n'+time.strftime('%a %d.%m.%Y, %H:%M:%S')+'\n')
        f.write("lattice:\n")
        f.write(L.Q.matrix().str() + "\n")
        for el in L.discriminant_form_iterator():
            #if stop:
            #    break
            #else:
            #    stop += 1
            print "\nelement:", el, to_go
            to_go -= 1
            f.write("\nelement: "+ matrix(el.list()).str() + "\n")
            
            for p in ps:#[p for p in ps if p != 2]:
                
                f.write("\nprime: " + p.str() + (5-len(p.str()))*" ")
                normalQ, S = L.local_normal_form(p)
                #print "local:\n", normalQ, "\n", normalQ.matrix()
                f.write("local vector: " + matrix(el._mu_p(p).list()).str() + "\n")
                #print "trans:\n", S

                for m in [el.Q + j for j in range(-1,2)]:
                    
                    #print "m: ", m
                   
                    #print "p=" + p.str(), el._mu_p(p), "Q:", el.Q, "W("+ p.str()+", "+ el.Q.str() +")="
                    w=el.Wpoly(p, m)
                    f.write((13-len(p.str()))*" " + "el.Wpoly("+p.str()+", "+ m.str()+"): " + str(w) + "\n") #+ str(ComplexField(10)(p**-s)) + "\n")
                    ww=el.W(p,m,s)
                    f.write((13-len(p.str()))*" " + "el.W("+p.str()+", "+ m.str()+", "+ str(s) +"): " + str(ww) + "\n\n")
                    
        f.seek(0)
        f.read()
    print "file closed:", f.closed
        
def test5(max_size=10, max_value = 3, matr=None):
    if matr:
        m = matr
    else:
        msize = floor(random() * max_size) + 1
        m = matrix(msize, msize, [floor(random()*(2 * max_value + 1 )) - max_value for i in range(msize * msize)])
        for x in range(msize):
            if floor(4*random()):
                m[:,x] = (2,3,5,7)[floor(4*random())]**floor(3*random()+1) * m[:,x]
        m = m + m.transpose()
    print m, m.det()
    test4(m)
    return m

#m = test5()#matr=matrix(3,3, [ 4, -12, -2, -12, -18, 9, -2, 9, 12]))

def test6(max_size=10, max_value = 3, matr=None):
    if matr:
        m = matr
    else:
        msize = floor(random() * max_size) + 1
        m = matrix(msize, msize, [floor(random()*(2 * max_value + 1 )) - max_value for i in range(msize * msize)])
        for x in range(msize):
            if floor(4*random()):
                m[:,x] = (2,3,5,7)[floor(4*random())]**floor(3*random()+1) * m[:,x]
        m = m + m.transpose()
    print m, m.det()
    w = {}
    for p in m.det().prime_divisors():
        w[p] = Lattice(m).weil_index(p)
        print p, Lattice(m).weil_index(p), "\n"
        print CC(Lattice(m).weil_index(p)), "\n"
        #print p, Lattice(m).weil_index_unstable(p), "\n"
        #print CC(Lattice(m).weil_index_unstable(p)), "\n"
        #print "*"*40, CC(Lattice(m).weil_index(p)) == CC(Lattice(m).weil_index_unstable(p)), "\n"
    return m, w

#m, w = test6()#matr=matrix(3,3, [ 4, -12, -2, -12, -18, 9, -2, 9, 12]))

def random_gram_matrix(min_size=1, max_size=5, max_value=3, max_det = 50):
    det = 0
    while det == 0 or abs(det) > max_det:
        msize = floor(random() * (max_size - min_size +1)) + min_size
        m = matrix(msize, msize, [floor(random()*(2 * max_value + 1 )) - max_value for i in range(msize * msize)])
        for x in range(msize):
            if floor(2*random()):
                m[:,x] = (2,3,5,7)[floor(4*random())]**floor(3*random()+1) * m[:,x]
        m = m + m.transpose()
        det = m.det()
    return m

def test_kloosterman_sum(m=None):
    if not m:
        m = random_gram_matrix(min_size=3)
    L = Lattice(m)
    print m, m.det()

    s = set()
    with open('testresults_kloosterman', 'r+') as f:
        f.seek(0,2)
        f.write('\n'+time.strftime('%a %d.%m.%Y, %H:%M:%S')+'\n')
        f.write("lattice:\n")
        f.write(L.Q.matrix().str() + "\n")

        for beta in L.discriminant_form_iterator():
            if beta.Q().is_integer():
                f.write("\nbeta: "+ matrix(beta.list()).str())
                for gamma in L.discriminant_form_iterator():
                    f.write("\n" + 4*" " + "gamma: "+ matrix(gamma.list()).str())
                    offset = floor(gamma.Q()) - gamma.Q() + 1
                    for c in range(1,6):
                        f.write("\n" + 8*" " + "c: "+ Integer(c).str())
                        for n in [offset + j for j in range(3)]:
                            f.write("\n" + 12*" " + "n: "+ n.str())
                            result = L._generalized_kloosterman_sum(c, beta, gamma, n)
                            try:
                                res = result.str()
                            except Exception:
                                try:
                                    res = QQ(result).str()
                                except Exception:
                                    try:
                                        res = (QQ(result.real_part()) + I * QQ(result.imag_part())).str()
                                    except Exception:
                                        try:
                                            res = RR(result).str()
                                        except Exception:
                                            res = CC(result).str()
                            s.add(result.abs()/(c**2))
                            print c, beta, gamma, n, result, (result.abs()/(c**2)).is_integer(), result.abs()/(c**2), s
                            f.write("\n" + 16*" " + "kloosterman_sum: "+ res)
        f.write("\n" + 16*" " + "2*Re(...): ")
        for ss in s:
            f.write(ss.str() + " ")
        f.seek(0)
        f.read()
    print "file closed:", f.closed
    return m, s

def test_kloosterman_sums():
    d = {}
    for j in range(20):
        m, s = test_kloosterman_sum()
        d[tuple(m.list())]=s
        print d
    return d

def test_2_adic_change_of_basis(max0=50, max1=50, max2=50):
    for k0 in range(-max0,max0):
        for k1 in range(-max1,max1):
            for k2 in range(-max2,max2):
                m = matrix(2,2,[2*k1, 1+2*k0, 1+2*k0, 2*k2])
                L = Lattice(m)
                for p in [2] + m.det().prime_divisors():
                    Q, S = L.local_normal_form(p)
                    if S.transpose() * L.Q.Hessian_matrix() * S != Q.Hessian_matrix():
                        return m, p, k0, k1, k2, False, m.det(), -m.det() % 8
                    #else:
                       #print p, k0, k1, k2, True, m.det(), -m.det() % 8

def test_random_gram_matrix(min_size=1, max_size=5, max_value=50, max_det = Infinity):
    m = random_gram_matrix(min_size=min_size, max_size=max_size, max_value=max_value, max_det = max_det)
    L = Lattice(m)
    for p in [2] + m.det().prime_divisors():
        Q, S = L.local_normal_form(p)
        if S.transpose() * L.Q.Hessian_matrix() * S != Q.Hessian_matrix():
            return m, p, False, m.det(), -m.det() % 8
        else:
            print p, True, m.det(), -m.det() % 8
    return m, True

def test_eisenstein_kudla_yang_vs_jacobi_forms(min_index =1, max_index = 10, max_weight = 20, prec = 500):
    for m in range(min_index, max_index+1):
        print "index:", m
        for k in range(4,max_weight+1,2):
            print "weight:", k
            L = Lattice(matrix(1,1,[-2*m]))
            print "start: Kudla Yang:", time.strftime('%a %d.%m.%Y, %H:%M:%S')
            kudla_yang = L.eisenstein_series(k-Integer(1)/Integer(2), prec=prec)
            print "start: Jacobi forms:", time.strftime('%a %d.%m.%Y, %H:%M:%S')
            jac = eisenstein_series_from_jacobi(k, m, prec=prec)
            print "end:", time.strftime('%a %d.%m.%Y, %H:%M:%S')
            for x in range(2*m):
                if jac[x] != kudla_yang[(x / Integer(2*m),)]:
                    return k,m,x,jac,kudla_yang


def test_eisenstein_kudla_yang_vs_jacobi_forms_2(m = ZZ(2), k = 4, prec = 20):
    jac = eisenstein_series_from_jacobi(k, m, prec=prec)
    L = Lattice(matrix(1,1,[-2*m]))
    kudla_yang = L.eisenstein_series(k-Integer(1)/Integer(2), prec=prec)
    for x in range(2*m):
        print ""#jac[x], kudla_yang[(x/Integer(2*m),)]
        for n in sorted(jac[x].keys()):
            a= jac[x][n]
            b= kudla_yang[(x/Integer(2*m),)][n]
            print x, n, a, b, a==b

def b(p, kappa, m, s, D, verbose=False):
    d = (kappa * m).squarefree_part()
    #d = Integer(d.numerator()*d.denominator()) # This should not be necessary
    if (d-1) % 4 != 0:
        d *= 4
    c = (4 * kappa * m / d).sqrt()
    vp = kronecker_symbol(d,p)
    X = p**(-s)
    k = c.valuation(p)
    if verbose:
        print "p:", p
        print "kappa:", kappa
        print "m:", m
        print "D:", D
        print "d:", d
        print "c:", c
        print "vp:", vp
        print "X:", X
        print "k:", k
    if k < 0:
        if verbose:
            print "case 1:", 1
        return 1
    elif D % p != 0:
        if verbose:
            print "case 2:", 1, - vp*X, + p**k * vp * X**(1+2*k), - p**(k+1) * X**(2*k+2), 1, - p * X**2
        return (1 - vp*X + p**k * vp * X**(1+2*k) - p**(k+1) * X**(2*k+2)) / (1 - p * X**2)
    else:
        if verbose:
            print "case 3:", ((1 - vp*X)*(1 - p**2*X**2) - p**(k+1)*vp*X**(1+2*k) + p**(k+2)*X**(2*k+2) + vp*p**(k+1)*X**(2*k+3) - p**(2*k+2)*X**(2*k+4)) / (1 - p*X**2)
        return ((1 - vp*X)*(1 - p**2*X**2) - p**(k+1)*vp*X**(1+2*k) + p**(k+2)*X**(2*k+2) + vp*p**(k+1)*X**(2*k+3) - p**(2*k+2)*X**(2*k+4)) / (1 - p*X**2)

def E8_matrix(n=1):
    return Integer(n)*matrix(8,8,[2,-1,0,0,0,0,0,0,
                   -1,2,-1,0,0,0,0,0,
                   0,-1,2,-1,0,0,0,-1,
                   0,0,-1,2,-1,0,0,0,
                   0,0,0,-1,2,-1,0,0,
                   0,0,0,0,-1,2,-1,0,
                   0,0,0,0,0,-1,2,0,
                   0,0,-1,0,0,0,0,2])

def H_matrix(n=1):
    return Integer(n)*matrix(2,2,[0,1,1,0])

def O_minus3_matrix(n=1):
    return Integer(n)*matrix(2,2,[2,1,1,2])

def theta1(prec = 10):
    result = {Integer(0):Integer(1)}
    n = floor(sqrt(2 * prec))
    if n*n < 2 * prec:
        n += 1
    two = Integer(2)
    for j in range(1,n):
        result[Integer(j)**two / two ] = two
    return result

def theta2(prec = 10):
    result = {Integer(0):Integer(1)}
    n = floor(sqrt(2 * prec))
    if n*n < 2 * prec:
        n += 1
    two = Integer(2)
    for j in range(1,n):
        if is_even(j):
            result[Integer(j)**two / two ] = two
        else:
            result[Integer(j)**two / two ] = -two
    return result

def theta3(prec = 10):
    result = dict()
    one = Integer(1)
    two = Integer(2) 
    n = floor(sqrt(2 * prec) - one / two) + 1
    for j in range(n):
        result[(Integer(j)+one / two)**two / two ] = two
    return result

def theta_product(power1, power2, power3, prec = 10):
    
    def pr(th1, th2):
        result = dict()
        for k1 in th1.keys():
            for k2 in th2.keys():
                k_new = k1 + k2
                if k_new < prec:
                    if result.has_key(k_new):
                        result[k_new] += th1[k1]*th2[k2]
                    else:
                        result[k_new] = th1[k1]*th2[k2]
        return result

    result = {Integer(0):Integer(1)}
    if power1 > 0:
        th1 = theta1(prec = prec)
    if power2 > 0:
        th2 = theta2(prec = prec)
    if power3 > 0:
        th3 = theta3(prec = prec)
    for x in range(power1):
        result = pr(result, th1)
    for x in range(power2):
        result = pr(result, th2)
    for x in range(power3):
        result = pr(result, th3)
    return result

def sum_of_theta_products(power_coefficient_dictionary, prec = 10):

    def su(a, th1, b, th2):
        result = dict()
        for k in th1.keys():
            result[k] = a * th1[k]
        for k in th2.keys():
            if result.has_key(k):
                result[k] += b * th2[k]
            else:
                result[k] = b * th2[k]
            if result[k] == 0:
                _ = result.pop(k)
        return result

    result = dict()

    for k in power_coefficient_dictionary.keys():
        result = su(1, result, power_coefficient_dictionary[k], theta_product(*k, prec = prec))

    return result

def test_eisenstein_series_bundschuh_diploma(prec = 1000):

    half = Integer(1)/Integer(2)
    
    g = matrix(4,4,[2,1,0,0,1,2,2,0,0,2,4,2,0,0,2,4])
    L = Lattice(g)
    print L.genus_symbol()
    eis = L.eisenstein_series(4, prec = prec)
    
    F0 = sum_of_theta_products({(0,0,8):-1, (8,0,0):half, (0,8,0):half}, prec = prec)
    F1 = sum_of_theta_products({(8,0,0):-half, (0,8,0):half}, prec = prec)
    
    a = (eis[(0,0,0,0)] == F0)
    b = (eis[(0,0,half,0)] == F1)
    c = (eis[(0,0,half,half)] == F1)
    d = (eis[(0,0,0,half)] == F1)
    
    print "O(2,6):", a and b and c and d # a, b, c, d, eis, F0, F1

    g = matrix(3,3,[2,1,0,1,2,2,0,2,4])
    L = Lattice(g)
    print L.genus_symbol()
    eis = L.eisenstein_series(7 * half, prec = prec)
    
    F0 = sum_of_theta_products({(7,0,0):-half, (0,7,0):-half, (4,3,0):1, (3,4,0):1}, prec = prec)
    F1 = sum_of_theta_products({(7,0,0):-half, (0,7,0):half, (4,3,0):-1, (3,4,0):1}, prec = prec)
    F2 = sum_of_theta_products({(4,0,3):-half, (0,4,3):-half}, prec = prec)
    F3 = F2
    
    a = (eis[(0,0,0)] == F0)
    b = (eis[(0,0,half)] == F1)
    c = (eis[(half,0,half*half)] == F2)
    d = (eis[(half,0,3*half*half)] == F3)
    
    print "O(2,5):", a and b and c and d # a, b, c, d, eis, F0, F1

    g = matrix(2,2,[2,0,0,2])
    L = Lattice(g)
    print L.genus_symbol()
    eis = L.eisenstein_series(3, prec = prec)
    
    F0 = sum_of_theta_products({(6,0,0):-half, (0,6,0):-half, (4,2,0):1, (2,4,0):1}, prec = prec)
    F1 = sum_of_theta_products({(4,0,2):-half, (0,4,2):-half}, prec = prec)
    F2 = F1
    F3 = sum_of_theta_products({(6,0,0):-half, (0,6,0):half, (4,2,0):-1, (2,4,0):1}, prec = prec)
    
    a = (eis[(0,0)] == F0)
    b = (eis[(0,half)] == F1)
    c = (eis[(half,0)] == F2)
    d = (eis[(half,half)] == F3)
    
    print "O(2,4):", a and b and c and d # a, b, c, d, eis, F0, F1

def vector_valued_mod_form_to_latex(coefficient_dict, prec = 10, max_letters = 48):
    
    #def frac_to_latex(f):
    #    f = QQ(f)
    #    n = f.numerator()
    #    d = f.denominator()
    #    if d == 1:
    #        return "{" + str(n) + "}"
    #    else:
    #        return "{\\frac{" + str(n) + "}{" + str(d) + "}}"
    
    result = "\\begin{tabular}{l|l}\nelement & $q$-expansion\\\\\\hline\n"

    #for element in sorted(coefficient_dict.keys()):
    #    if type(element) == sage.rings.integer.Integer or type(element) == int:
    #        result += "$" + str(element) + "$ & $"
    #    elif len(element) == 1:
    #        result += "$" + str(element[0]) + "$ & $"
    #    else:
    #        result += "$" + str(element) + "$ & $"
    #    for exponent in sorted(coefficient_dict[element].keys()):
    #        if exponent < prec:
    #            coeff = coefficient_dict[element][exponent]
    #            if coeff != 0:
    #                if exponent == 0:
    #                    result += frac_to_latex(coeff) + " + "
    #                else:
    #                    result += frac_to_latex(coeff) + "q^" + frac_to_latex(exponent) + " + "
    #        else:
    #            exponent -= 1
    #            break
    #    result += "\\operatorname{O}(q^" + frac_to_latex(exponent + 1) + ")$\\\\\n"
    #
    #result += "\\end{tabular}"

    def frac_to_latex(f):
        f = QQ(f)
        if f == 0:
            return "0", 0
        n = f.numerator()
        d = f.denominator()
        length = floor(max(log(abs(n),10), log(d,10)))
        if d == 1:
            return "  -"[len(str(sign(n)))] + str(abs(n))#, length + 3
        else:
            return "  -"[len(str(sign(n)))] + "\\frac{" + str(abs(n)) + "}{" + str(d) + "}" #, 0.8 * length + 3
    
    #result += "\\\\\n\n\\begin{tabular}{l|l}\nelement & $q$-expansion\\\\\\hline\n"

    keys = sorted(coefficient_dict.keys())
    #length = max([len(str(element)) for element in keys])

    for element in keys:
        #l = length
        if type(element) == sage.rings.integer.Integer or type(element) == int:
            result += "$" + str(element) + "$ & $"
        elif len(element) == 1:
            result += "$" + str(element[0]) + "$ & $"
        #    l -= 3
        else:
            result += "$" + str(element) + "$ & $"
        for exponent in sorted(coefficient_dict[element].keys()):
            if exponent <= prec:
                coeff = coefficient_dict[element][exponent]
                if coeff != 0:
                    frac1 = frac_to_latex(coeff)
                    frac2 = frac_to_latex(exponent)
                    #frac1, l1 = frac_to_latex(coeff)
                    #l += l1
                    #frac2, l2 = frac_to_latex(exponent)
                    #l += 0.8 * (l2 - 2)
                    #l += l2
                    #if l > max_letters:
                    #    exponent -= 1
                    #    break
                    if result[-3:] != "& $" and frac1[0] == " ":
                        frac1 = " + " + frac1[1:]
                    if exponent == 0:
                        result += frac1
                    else:
                        #print frac, l, type(frac), type(l)
                        result += frac1 + "\\,q^{" + frac2 + "}"
            else:
                exponent -= 1
                break
        result += "+\\operatorname{O}(\\,q^{" + frac_to_latex(exponent + 1) + "})$\\\\\n" #\quad" + str(l) +"

    result += "\\end{tabular}"

    return result

def latex_test_eisenstein_kudla_yang_vs_jacobi_forms(min_index =1, max_index = 20, max_weight = 20, prec = 500, latex_prec = 5, file = "latex_ausgabe"):

    precision_exceptions = {
        (1,10) : 4, (1,12) : 4, (1,14) : 4, (1,16) : 3, (1,18) : 3, (1,20) : 3,
        (2,10) : 4, (2,12) : 4, (2,14) : 4, (2,16) : 3, (2,18) : 3, (2,20) : 2,
        (3,8) : 4, (3,10) : 3, (3,12) : 3, (3,14) : 3, (3,16) : 3, (3,18) : 2, (3,20) : 2,
        (4,8) : 4, (4,10) : 4, (4,12) : 4, (4,14) : 3, (4,16) : 3, (4,18) : 2, (4,20) : 2,
        (5,6) : 4, (5,8) : 4, (5,10) : 3, (5,12) : 3, (5,14) : 3, (5,16) : 2, (5,18) : 2, (5,20) : 2,
        (6,8) : 4, (6,10) : 3, (6,12) : 3, (6,14) : 3, (6,16) : 2, (6,18) : 2, (6,20) : 2,
        (7,6) : 4, (7,8) : 4, (7,10) : 3, (7,12) : 3, (7,14) : 2, (7,16) : 2, (7,18) : 2, (7,20) : 2,
        (8,8) : 4, (8,10) : 4, (8,12) : 3, (8,14) : 3, (8,16) : 2, (8,18) : 2, (8,20) : 2,
        (9,6) : 4, (9,8) : 4, (9,10) : 3, (9,12) : 3, (9,14) : 2, (9,16) : 2, (9,18) : 2, (9,20) : 2,
        (10,8) : 4, (10,10) : 4, (10,12) : 3, (10,14) : 3, (10,16) : 2, (10,18) : 2, (10,20) : 2,
        (11,6) : 4, (11,8) : 4, (11,10) : 3, (11,12) : 3, (11,14) : 2, (11,16) : 2, (11,18) : 2, (11,20) : 2,
        (12,8) : 4, (12,10) : 4, (12,12) : 3, (12,14) : 3, (12,16) : 2, (12,18) : 2, (12,20) : 1,
        (13,6) : 4, (13,8) : 4, (13,10) : 3, (13,12) : 3, (13,14) : 2, (13,16) : 2, (13,18) : 2, (13,20) : 2,
        (14,8) : 4, (14,10) : 3, (14,12) : 3, (14,14) : 3, (14,16) : 2, (14,18) : 2, (14,20) : 1,
        (15,6) : 4, (15,8) : 4, (15,10) : 3, (15,12) : 3, (15,14) : 2, (15,16) : 2, (15,18) : 2, (15,20) : 2,
        (16,8) : 4, (16,10) : 4, (16,12) : 3, (16,14) : 3, (16,16) : 2, (16,18) : 2, (16,20) : 2,
        (17,6) : 4, (17,8) : 4, (17,10) : 3, (17,12) : 3, (17,14) : 2, (17,16) : 2, (17,18) : 2, (17,20) : 2,
        (18,8) : 4, (18,10) : 3, (18,12) : 3, (18,14) : 2, (18,16) : 2, (18,18) : 2, (18,20) : 2,
        (19,6) : 4, (19,8) : 4, (19,10) : 3, (19,12) : 3, (19,14) : 2, (19,16) : 2, (19,18) : 2, (19,20) : 1,
        (20,8) : 4, (20,10) : 3, (20,12) : 3, (20,14) : 2, (20,16) : 2, (20,18) : 2, (20,20) : 2,
    }
    
    result = ""
    
    for m in range(min_index, max_index+1):
        print "index:", m

        result += "\\subsection{Index " + str(m) + "}\n\n" 
        
        for k in range(4,max_weight+1,2):

            if (m,k) in precision_exceptions.keys():
                l_prec = min(latex_prec, precision_exceptions[(m,k)])
            else:
                l_prec = latex_prec

            #result += "\\subsection{Index " + str(m) + ", weight" + str(k) + "}\n" 
            
            print "weight:", k
            L = Lattice(matrix(1,1,[-2*m]))
            print "start: Kudla Yang:", time.strftime('%a %d.%m.%Y, %H:%M:%S')
            kudla_yang = L.eisenstein_series(k-Integer(1)/Integer(2), prec=prec)
            print "start: Jacobi forms:", time.strftime('%a %d.%m.%Y, %H:%M:%S')
            jac = eisenstein_series_from_jacobi(k, m, prec=prec)
            print "end:", time.strftime('%a %d.%m.%Y, %H:%M:%S')
            for x in range(2*m):
                if jac[x] != kudla_yang[(x / Integer(2*m),)]:
                    return k,m,x,jac,kudla_yang
            #result += "The first " +  str(prec) + " Fourier coefficients coincide for each component.\n"
            #result += "The first " +  str(latex_prec) + " Fourier coefficients are given in table "
            #result += "\\ref{tab:eis_jacobi_ind_" + str(m) + "_weight_" + str(k) +"}.\n"
            result += "\\begin{table}[!ht]\n\\centering"
            result += vector_valued_mod_form_to_latex(kudla_yang, prec = l_prec)
            result += "\\caption{Eisenstein series from Jacobi forms for index $" + str(m) + "$ and weight $" + str(k) + "$}"
            result += "\\label{tab:eis_jacobi_ind_" + str(m) + "_weight_" + str(k) +"}\n"
            result += "\\end{table}\n\n"

            if k % 10 == 0:
                result += "\\clearpage\n\n"                 

        result += "\\clearpage\n\n" 

    with open('latex_ausgabe', 'r+') as f:
        f.write(result)

    #print result

def logged_test_eisenstein_kudla_yang_vs_jacobi_forms(min_index = 1, max_index = 20, max_weight = 50, prec = 1000, file_name = "jacobi_log"):
    
    for m in range(min_index, max_index+1):
        
        for k in range(4,max_weight+1,2):

            result = "Index " + str(m) + ", weight " + str(k) 
            
            L = Lattice(matrix(1,1,[-2*m]))
            
            result += "\nstart: Kudla Yang:   " + time.strftime('%a %d.%m.%Y, %H:%M:%S')
            kudla_yang = L.eisenstein_series(k-Integer(1)/Integer(2), prec=prec)
            result += "\nstart: Jacobi forms: " + time.strftime('%a %d.%m.%Y, %H:%M:%S')
            jac = eisenstein_series_from_jacobi(k, m, prec=prec)
            result += "\nend:                 " + time.strftime('%a %d.%m.%Y, %H:%M:%S')
            for x in range(2*m):
                if jac[x] != kudla_yang[(x / Integer(2*m),)]:
                    return k,m,x,jac,kudla_yang
            result += "\nThe Eisenstein series coincide for the first " + str(prec) + " Fourier coefficients in each component.\n\n"

            with open(file_name, 'r+') as f:
                f.seek(0,2)
                f.write(result)

def test_representation_numbers_bruinier_kuss(N, max_a = 20):
    L = Lattice(ZZ, 2, [0,N,0]) # Scaled hyperbolic plane
    for el in L.discriminant_form_iterator():
        gamma1 = N * el[0]
        gamma2 = N * el[1]
        Q = el.Q()
        for a in range(1, max_a + 1):
            f = ZZ(a).factor()
            for l in range(a):
                n = l - Q
                theo_result = 1
                for (p, nu) in f:
                    theo_result *= representation_number_Bruinier_Kuss_theoretical(N, gamma1, gamma2, n, p, nu)
                count_result = el.representation_number_Bruinier_Kuss(n, a)
                print "N="+str(N), "gamma:", gamma1, gamma2, el, "n="+str(n), "a="+str(a), "theo="+str(theo_result), "count="+str(count_result), theo_result == count_result
                if theo_result != count_result:
                    return False
    return True

def test_representation_numbers_bruinier_kuss_levels(min_N = 1, max_N = 10, max_a = 100):
    for N in range(min_N, max_N+1):
        if not test_representation_numbers_bruinier_kuss(N, max_a=max_a):
            return False
    return True
